NOTE: Voila does not support non-ghost, non-atomic statements in a context
      where an atomic statement is expected.

⟦s⟧ ≡ // translate: PStatement -> Stmt
  if !is-ghost(s) &&
        atomicity(s) != atomic &&
        expected-atomicity(s) == atomic:
    ERROR // Combination isn't supported

  mustHavocAfter ≡ s' => 
    !is-atomic(s') || 
    (is-atomic(s') && !is-ghost(s') && expected-atomicity(s') != atomic)

  vprHavoc ≡
    if mustHavocAfter(s):
      // Voila does certain optimisations here in order to avoid stabilising
      // more than once between statements. We can probably ignore this detail here.
      stabilise-regions(all region types declared by the current program)
    else:
      skip;

  return 
    ⟪s⟫
    vprHavoc


⟪s⟫ ≡ // directlyTranslate: PStatement -> Stmt

⟪s1; s2⟫ ≡ ⟦s1⟧; ⟦s2⟧

⟪skip⟫ ≡ assert true

⟪if (b) { s1; } else { s2; }⟫ ≡

  Let level_store be a fresh variable

  return
    level_store := level;
    if (⟦b⟧) {
      ⟦s1⟧;
      assert level == level_store;
    } else {
      ⟦s2⟧
      assert level == level_store;
    }
    level := level_store;

⟪while (b) invariant I; { s; }⟫ ≡

  Let level_store be a fresh variable

  inhaleSkolemizationFunctionFootprints ≡ ... // Can probably be omitted

  preLabel ≡ label pre_atomicityl

  Let R1, R2, ... be all existing regions with the following formal arguments respectively
    (id r_1, T1_1 x1_1, ...), (id r_2, T1_2 x1_2, ...), ...

  preserveAtomicityContext ≡
    inhale forall id r_1, T1_1 x1_1, ... :: acc(R1_A_fp(r_1, x1_1, ...), write);
    inhale forall id r_1, T1_1 x1_1, ... :: R1_A(r_1, x1_1, ...) == old[preLabel](R1_A(r_1, x1_1, ...));
    inhale forall id r_2, T1_2 x1_2, ... :: acc(R2_A_fp(r_2, x1_2, ...), write);
    inhale forall id r_2, T1_2 x1_2, ... :: R2_A(r_2, x1_2, ...) == old[preLabel](R2_A(r_2, x1_2, ...));
    ...

  return
    level_store := level;
    preLabel;
    while (⟦b⟧) invariant ⟦I⟧ {
      inhaleSkolemizationFunctionFootprints;
      preserveAtomicityContext;
      stabilise-and-infer-context-regions; // in reality we only infer
      ⟦s⟧
      assert level == level_store;
    }
    level := level_store;

⟪x := e⟫ ≡ ⟦x⟧ := ⟦e⟧

⟪x := y.f⟫ ≡ ⟦x⟧ := ⟦y.f⟧

⟪x.f := e⟫ ≡ ⟦x.f⟧ := ⟦e⟧

⟪unfold P(e1, ...)⟫ ≡ // TODO
⟪fold P(e1, ...)⟫ ≡ // TODO

⟪inhale a⟫ ≡
  inhale ⟦a⟧
  extract-logical-variable-bindings(a)

⟪exhale a⟫ ≡
  extract-logical-variable-bindings(a)
  exhale ⟦a⟧

⟪assert a⟫ ≡
  extract-logical-variable-bindings(a)
  assert ⟦a⟧

⟪havoc x.f⟫ ≡ 
  exhale acc(⟦x.f⟧); 
  inhale acc(⟦x.f⟧)

⟪havoc x⟫ ≡ ⟦x⟧ := havoc_T() // where T is the Viper type of x

⟪use_region_interpretation R(r, e1, ...)⟫ ≡ // TODO

⟪use lemma(e1, ...)⟫ ≡ // TODO

⟪y1, ... := proc(e1, ...)⟫ ≡

  preLabel ≡ label pre_calll

  Let f1, ... be the formal parameters of method proc

  Let m be the modifier of method proc

  Let P be the precondition of method proc
  Let Q be the postcondition of method proc

  Let context1 (and analogously, context2, ...) denote an interference context clause of the shape
    n1 in U1 on r1
  where a region assertion of the form
    R1(args1, n1) with the state type T1
  is contained in P

  vprInterferenceCheck ≡
    switch (m):
      case NoneAtomic:      assert true
      case PrimitiveAtomic: assert true
      case AbstractAtomic:
        assert forall s: ST1 ::
                 s in R1_X(args1[f1, .... ↦ ⟦e1⟧, ...])
                 ==> s in ⟦U1⟧[n1, .... ↦ R1_state(⟦args1⟧[f1, .... ↦ ⟦e1⟧, ...]), ...][f1, .... ↦ ⟦e1⟧, ...]

        assert forall s: ST2 ::
                 s in R2_X(args1[f1, .... ↦ ⟦e1⟧, ...])
                 ==> s in ⟦U2⟧[n1, .... ↦ R1_state(⟦args1⟧[f1, .... ↦ ⟦e1⟧, ...]), ...][f1, .... ↦ ⟦e1⟧, ...]

        ...


  Let l1, l2, ... be the level expressions that occur in region assertions in P

  vprAssertLvlConstraint ≡
    assert level > ⟦l1⟧[f1, .... ↦ ⟦e1⟧, ...] &&
           level > ⟦l2⟧[f1, .... ↦ ⟦e1⟧, ...] &&
           ...

  vprAssertAtomicityContextConstraint ≡
    assert atomicity_level > ⟦l1⟧[f1, .... ↦ ⟦e1⟧, ...] &&
           atomicity_level > ⟦l2⟧[f1, .... ↦ ⟦e1⟧, ...] &&
           ...

  return
    vprInterferenceCheck;
    preLabel;
    vprAssertLvlConstraint;
    vprAssertAtomicityContextConstraint;
    exhale ⟦P⟧[f1, .... ↦ ⟦e1⟧, ...]
    label pre_havoc;
    stabilise-region-instances(pre_havoc)
    havoc y1, ...
    inhale ⟦Q⟧[f1, .... ↦ ⟦e1⟧, ...]


The translation of rule blocks such as make_atomic is defined in translation_rules.txt

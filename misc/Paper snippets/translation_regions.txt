TODO: Distinguish in- and out-arguments in declaration

region R(id r, T1 x1, T2 x2, ...)
  guards {
    modifier1 G1(T'1, T'2, ... )
    ...
  }
  interpretation { I }
  state { ϕ }
  actions {
    T''1 y1, ... | c(y1, ...) | G'1(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...) // action1
    ...
  }

=========================================================================

region-interference-X(R) ≡
  Let r, x1, ... be region R's formal in-arguments (with appropriate Viper types)
  Let ϕ be its state expression and T the type of ϕ

  return
    function R_X(r: T0, x1: T1, ...): Set[T]


region-predicate(R) ≡
  Let r, x1, ... be region R's formal in-arguments (with appropriate Viper types)
  Let I be its interpretation

  return
    predicate R_interp(r: T0, x1: T1, ...) { 
      ⟦I⟧
    }


region-state-function(R) ≡
  Let r, x1, ... be region R's formal in-arguments (with appropriate Viper types)
  Let ϕ be its state expression and T the type of ϕ

  // TODO: Decider whether or not we want/have to include the state trigger function trick/hack

  return
    function R_state(r: T0, x1: T1, ...): T
      requires R_interp(r, x1, ...)
    { unfolding R_interp(r, x1, ...) in ⟦ϕ⟧ }

=========================================================================

state-constraints-from-action(action, vprFrom, vprTo)
  // stateConstraintsFromAction: PAction, Exp, Exp, Exp -> Exp
    action,                    // PAction
    vprFrom,                   // vpr.Exp
    vprTo,                     // vpr.Exp

  Let action denote an action of the shape
    T''1 y1, ... | c(y1, ...) | G'1(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...)
  of a region R and let G'1 denote a guard of that region of the shape
    modifier1 G(T'1, T'2, ... )

  may-env-hold-action-guard ≡
    if modifier1 is 'duplicable':
      true
    else: // modifier1 is 'unique'
      perm(R_G'1(r, ⟦g1(y1, ...)⟧, ...)) == none

  return
    exists y1: T''1, ... ::
      ⟦from(y1, ...)⟧ == vprFrom &&
      ⟦to(y1, ...)⟧ == vprTo &&
      ⟦c(y1, ...)⟧ &&
      may-env-hold-action-guard


region-state-change-allowed-by-guard(R, r, v1, ..., G, guard, vFrom, vTo) ≡
  // regionStateChangeAllowedByGuard:
  //    PRegion, Vector[vpr.Exp], String, PredicateAccessPredicate, Exp, Exp --> Assert

  Let guard denote a Viper predicate instance R_G(w0, w1, ...)

  relevantActions ≡ all actions of R whose guard is G

  vprActionConstraints ≡ {
    relevantActions map (action =>
      // Let action denote an action of the shape
      //   T''1 y1, ... | c(y1, ...) | G(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...)

      vprExistentialConstraint ≡
        // state-constraints-from-action(action, vFrom, vTo)
        //   but replace 'may-env-hold-action-guard' with true,
        //   which yields the following:
        exists y1: T''1, ... ::
          ⟦from(y1, ...)⟧ == vFrom &&
          ⟦to(y1, ...)⟧ == vTo &&
          ⟦c(y1, ...)⟧

      // The SMT solver will most likely fail to prove the existentials,
      // so we have to find witnesses for the existentially quantified
      // variables y1, y2, ....
      //
      // Currently, only those actions are supported where each existentially
      // quantified variables y_i is used as one of the following:
      //   1) the from-expression, i.e. from(y1, ...) ≡ y_i,
      //      in which case y_i can be instantiated with vFrom
      //   2) the to-expression, i.e. to(y1, ...) ≡ y_i,
      //      in which case y_i can be instantiated with vTo
      //   3) a "direct" argument of the guard, i.e. the action's guard has 
      //      the shape G(..., y_i, ...), in which case y_i can be instantiated
      //      with the corresponding w_i from R_G(w0, w1, ...)
      //
      // A more general solution would be to require that there exists inverse 
      // functions for each y_i so that it can be computed from from-/to-expression/guard.
      //
      // Let v'1, v'2, ... be the witnesses for y1, y2, ....

      vprExistentialConstraint
        but instantiate y1 with v'1, y2 with v'2, ...
    )
  }

  return
    // No state change, or according to vprActionConstraints
    assert
      vFrom == vTo ||
      (⟦from1(v'1, ...)⟧ == vFrom && ⟦to1(v'1, ...)⟧ == vTo && ⟦c1(v'1, ...)⟧) || // State changed according to action1
      (⟦from2(v'1, ...)⟧ == vFrom && ⟦to2(v'1, ...)⟧ == vTo && ⟦c2(v'1, ...)⟧) || // State changed according to action2
      ...

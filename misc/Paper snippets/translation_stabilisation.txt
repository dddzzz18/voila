region R(id r, T1 x1, T2 x2, ...)
  guards {
    modifier1 G1(T'1, T'2, ... )
    ...
  }
  interpretation { I }
  state { ϕ }
  actions {
    T''1 y1, ... | c(y1, ...) | G'1(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...) // action1
    ...
  }

=========================================================================

stabilise-regions(regions) ≡
  // stabilizeRegions: Vector[PRegion], String -> Stmt

  Let regions be a set of regions R1, R2, ...

  return
    label pre_havoc;
    stabilise-region-instances(R1, pre_havoc);
    stabilise-region-instances(R2, pre_havoc);
    ...


stabilise-region-instance(R, r, v1, ..., preHavocLabel) ≡
  // stabilizeRegionInstance: PRegion, Vector[vpr.Exp], vpr.Label -> Seqn

  Let x0, x1, x2, ... be the formal arguments of region R

  return
    stabilise-region-instances(R, preHavocLabel)
      with following substitutions performed (until a fix point is reached):
        1. forall x0, x1, ... :: body  -->  body[r/x0, v1/x1, ...]
        2. perm(R_interp(r, v1, ...))  -->  write


stabilise-region-instances(R, preHavocLabel) ≡
  // stabilizeAllRegionInstances: PRegion, Label -> Seqn

  actionFilter ≡ _ => true
  postRegionState ≡ args => R_state(args)
  preRegionState ≡ args => old[preHavocLabel](postRegionState(args))
  prePermissions ≡ e => old[preHavocLabel](e)
  stateTrigger ≡ ... // TODO: Decider whether or not we want/have to include the state trigger function trick/hack

  return
    stabilise-all-region-instances( // generateCodeForStabilizingAllRegionInstances
      R,
      actionFilter,
      preRegionState,
      postRegionState,
      prePermissions,
      stateTrigger)


stabilise-all-region-instances( // generateCodeForStabilizingAllRegionInstances
    R,                          // PRegion
    actionFilter,               // PAction => Boolean
    preRegionState,             // Vector[vpr.Exp] => vpr.Exp
    postRegionState,            // Vector[vpr.Exp] => vpr.Exp
    prePermissions,             // vpr.Exp => vpr.Exp
    stateTrigger) ≡             // Vector[vpr.Exp] => vpr.Trigger

  Let 
    id r, T1 x1, T2 x2, ... 
  be the formal arguments of region R

  Let action1 (and analogously, action2, ...) denote an action of the shape
    T''1 y1, ... | c(y1, ...) | G'1(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...)
  and let G'1 denote a guard of region R of the shape
    modifier1 G(T'1, T'2, ... )

  preHavocRegionPermissions ≡ 
    prePermissions(perm(R_interp(r, x1, ...)))

  vprStateConstraintsFromActions ≡
       state-constraints-from-action(action1, preRegionState(r, x1, ...), postRegionState(r, x1, ...))
    || state-constraints-from-action(action2, preRegionState(r, x1, ...), postRegionState(r, x1, ...))
    || ...

  vprPreliminaryResult1 ≡
    exhale forall id r, T1 x1, ... :: acc(R_interp(r, x1, ...), preHavocRegionPermissions);
    inhale forall id r, T1 x1, ... :: acc(R_interp(r, x1, ...), preHavocRegionPermissions);
    inhale forall id r, T1 x1, ... :: {stateTrigger(r, x1, ...)}
      none < preHavocRegionPermissions ==> (
        (none < perm(r.diamond) ==> postRegionState(r, x1, ...) in R_X(r, x1, ...)) &&
        (postRegionState(r, x1, ...) == preRegionState(r, x1, ...) || 
        vprStateConstraintsFromActions));

  // TODO: Necessary for the verification to succeed, but we can probably
  //       ignore it in the formalisation since it's standard skolemisation.
  // vprPreliminaryResult2 ≡
  //   skolemise-existentials(vprPreliminaryResult1)

  // TODO: Can be ignored: renames quantified variables, solely because Viper
  //       doesn't allow quantified variables to shadow local ones.
  // vprPreliminaryResult3 ≡
  //   sanitise-bound-variable-names(vprPreliminaryResult2)

  return vprPreliminaryResult

=========================================================================

stabilise-all-instances(R, args, preLabel) ≡

  preRegionState ≡ args => old[preLabel](R_state(args))
  stateConstraint ≡ possible-next-state-constraint(R, preRegionState)

  vprResult ≡ constrain-all(R, stateConstraint, preLabel)

  return vprResult


infer-context-all-instances(R, args, preLabel) ≡

  preRegionState ≡ args => old[preLabel](R_state(args))
  interferenceContextConstraint ≡ contains-all-possible-next-states-constraint(R, preRegionState)

  vprResult ≡ constrain-all(R_X, interferenceContextConstraint, preLabel)

  return vprResult


stabilise-and-infer-context-all-instances(R, args, preLabel) ≡

  preRegionState ≡ args => old[preLabel](R_state(args))
  interferenceContextConstraint ≡ contains-all-possible-next-states-constraint(R, preRegionState)
  stateConstraint ≡ contained-in-interference(R)

  vprResult ≡
    constrain-all(R_X, interferenceContextConstraint, preLabel);
    constrain-all(R, stateConstraint, preLabel);

  return vprResult


constrain-all(
    Q,             // R, R_X, ...
    constraint,    // Vector[vpr.Exp] => vpr.Exp => vpr.Exp
    preLabel)      // Label

  Let
    id r, T1 x1, T2 x2, ...
  be the formal arguments of Q

  vprSelect ≡
    havoc-all(Q, preLabel);
    inhale forall id r, T1 x1, ... :: available(Q, preLabel)(r, x1, ..., ) ==> constraint(r, x1, ...)(Q(r, x1, ...));

  return vprSelect


link-interference-context(R, args) ≡

  Let ϕ be the state of region R and T the type of ϕ
  Let I be the interpretation of region R

  Let
    id r, T1 x1, T2 x2, ...
  be the formal arguments of R

  Let IR1(args1), IR2(args2), ... be the region assertions that occur in I
  Let T1', T2', ... be the types of the states of the regions IR1, IR2, ....

  vprState ≡ ⟦ϕ⟧[r, x1, ... ↦ args][IR1, IR2, ... ↦ m1, m2, ...]

  vprResult ≡
    label preLabel
    havoc_single(IR1_X, ⟦args1⟧[r, x1, ... ↦ args], preLabel);
    havoc_single(IR2_X, ⟦args1⟧[r, x1, ... ↦ args], preLabel);
    ...
    inhale forall m1: T1', m2: T2', ... ::
      vprState in R_X(args) <==> m1 in IR1_X(⟦args1⟧[r, x1, ... ↦ args]) &&
                                 m2 in IR2_X(⟦args2⟧[r, x1, ... ↦ args]) &&
                                 ...

  return vprResult


possible-next-state-constraint( // possibleNextStateConstraint
    R,                          // PRegion
    preRegionState)(            // Vector[vpr.Exp] => vpr.Exp
    args,                       // Vector[vpr.Exp]
    β) ≡                        // vpr.Exp

  Let action1 (and analogously, action2, ...) denote an action of the shape
    T''1 y1, ... | c(y1, ...) | G'1(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...)
  and let G'1 denote a guard of region R of the shape
    modifier1 G(T'1, T'2, ... )

  vprStateConstraintsFromActions ≡
       state-constraints-from-action(action1, preRegionState(args), β)
    || state-constraints-from-action(action2, preRegionState(args), β)
    || ...

  vprConstraint ≡
       (none < perm(r.diamond) ==> β in R_A(args))
    && (β == preRegionState(args) || vprStateConstraintsFromActions)

  return vprConstraint


contains-all-possible-next-states-constraint(R, preRegionState)(args, β) ≡

  vprConstraint ≡
    forall T m :: m in β <==> possible-next-state-constraint(R, preRegionState)(args, m)

  return vprConstraint


contained-in-interference(R)(args, β) ≡

  vprConstraint ≡
    β in R_X(args)

  return vprConstraint


available(R, preLabel)(args) ≡ none < old[preLabel](perm(R_interp(args)))


havoc-all(R, preLabel) ≡

  Let
    id r, T1 x1, T2 x2, ...
  be the formal arguments of region R

  preHavocRegionPermissions ≡
    old[preLabel](perm(R_interp(r, x1, ...)))

  vprHavoc ≡
    exhale forall id r, T1 x1, ... :: acc(R_interp(r, x1, ...), preHavocRegionPermissions);
    inhale forall id r, T1 x1, ... :: acc(R_interp(r, x1, ...), preHavocRegionPermissions);

  return vprHavoc


available(R_X, preLabel)(args) ≡ none < old[preLabel](perm(R_interp(args)))


havoc-single(R_X, args, preLabel) ≡

  vprHavoc ≡
    exhale acc(R_X_fp(args), write);
    inhale acc(R_X_fp(args), write);

  return vprHavoc


havoc-all(R_X, preLabel) ≡

  Let
    id r, T1 x1, T2 x2, ...
  be the formal arguments of region interference R_X

  vprHavoc ≡
    exhale forall id r, T1 x1, ... :: acc(R_X_fp(r, x1, ...), write);
    inhale forall id r, T1 x1, ... :: acc(R_X_fp(r, x1, ...), write);

  return vprHavoc
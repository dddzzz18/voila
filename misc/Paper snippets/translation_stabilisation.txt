region R(id r, T1 x1, T2 x2, ...)
  guards {
    modifier1 G1(T'1, T'2, ... )
    ...
  }
  interpretation { I }
  state { ϕ }
  actions {
    T''1 y1, ... | c(y1, ...) | G(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...) // action1
    ...
  }

=========================================================================

stabilise-region-instances(R, preHavocLabel) ≡
  // stabilizeAllRegionInstances: PRegion, Label -> Seqn

  actionFilter ≡ _ => true
  postRegionState ≡ args => R_state(args)
  preRegionState ≡ args => old[preHavocLabel](postRegionState(args))
  prePermissions ≡ e => old[preHavocLabel](e)
  stateTrigger ≡ ... // TODO: Decider whether or not we want/have to include the state trigger function trick/hack

  stabilise-all-region-instances( // generateCodeForStabilizingAllRegionInstances
    R,
    actionFilter,
    preRegionState,
    postRegionState,
    prePermissions,
    stateTrigger)


stabilise-all-region-instances( // generateCodeForStabilizingAllRegionInstances
    R,                          // PRegion
    actionFilter,               // PAction => Boolean
    preRegionState,             // Vector[vpr.Exp] => vpr.Exp
    postRegionState,            // Vector[vpr.Exp] => vpr.Exp
    prePermissions,             // vpr.Exp => vpr.Exp
    stateTrigger) ≡             // Vector[vpr.Exp] => vpr.Trigger

  Let id r, T1 x1, T2 x2, ... be the formal arguments of region R

  preHavocRegionPermissions ≡ 
    prePermissions(perm(R_interp(r, x1, ...)))

  vprStateConstraintsFromActions ≡
       state-constraints-from-action(
         action1, 
         preRegionState(r, x1, ...), postRegionState(r, x1, ...),
         check-if-environment-may-hold-guard(R, r, action1)
       )
    || state-constraints-from-action(action2, ....)
    || ...

  vprPreliminaryResult1 ≡
    exhale forall id r, T1 x1, ... :: acc(R_interp(r, x1, ...), preHavocRegionPermissions);
    inhale forall id r, T1 x1, ... :: acc(R_interp(r, x1, ...), preHavocRegionPermissions);
    inhale forall id r, T1 x1, ... :: {stateTrigger(r, x1, ...)}
      none < preHavocRegionPermissions ==> (
        (none < perm(r.diamond) ==> postRegionState(r, x1, ...) in R_X(r, x1, ...)) &&
        (postRegionState(r, x1, ...) == preRegionState(r, x1, ...) || 
        vprStateConstraintsFromActions));

  vprPreliminaryResult2 ≡
    skolemise-existentials(vprPreliminaryResult1) // TODO: Define

  vprPreliminaryResult3 ≡
    sanitise-bound-variable-names(vprPreliminaryResult2) // TODO: Define

  vprPreliminaryResult3

=========================================================================

state-constraints-from-action( // stateConstraintsFromAction
    action,                    // PAction
    vprFrom,                   // vpr.Exp
    vprTo,                     // vpr.Exp
    vprGuardCheck) ≡           // vpr.Exp

  Let action denote an action of the shape
    T1 y1, ... | c(y1, ...) | G(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...)

  exists y1: T1, ... ::
    ⟦from(y1, ...)⟧ == vprFrom &&
    ⟦to(y1, ...)⟧ == vprTo &&
    ⟦c(y1, ...)⟧ &&
    vprGuardCheck

=========================================================================

check-if-environment-may-hold-guard(R, r, action) ≡
  // assembleCheckIfEnvironmentMayHoldActionGuard: PRegion, Exp, PAction -> Exp

  Let action denote an action of the shape
    T1 y1, ... | c(y1, ...) | G(g1(y1, ...), ...): from(y1, ...) ~> to(y1, ...)
  and let G denote a guard of region R of the shape
    modifier1 G(T'1, T'2, ... )

  if modifier1 is 'duplicable': 
    true
  else: // modifier1 is 'unique'
    perm(R_G(r, ⟦g1(y1, ...)⟧, ...)) == none

/* Axioms taken from Dafny
 * Sources:  dafny/Binaries/DafnyPrelude.bpl, dafny/Test/dafny0/Maps.dfy
 * Revision: 6270caf234d41ea82501ccade147a1d56c31cf21
 */
 
domain Map[U, V] {
  // A Map is defined by three functions, Map#Domain, Map#Elements, and #Map#Card.

  function Map_domain(m: Map[U, V]): Set[U]
  // function Map#Elements<U,V>(Map U V) : [U]V;
  function Map_card(m: Map[U, V]): Int
  function Map_lookup(m: Map[U, V], u: U): V

  // TODO: axiomatise Map_lookup
  
  axiom Map_card_non_neg {
    forall m: Map[U, V] :: { Map_card(m) } 0 <= Map_card(m)
  }
  
  // The set of Keys of a Map are available by Map#Domain, and the cardinality of that
  // set is given by Map#Card.

  axiom Map_card_domain {
    forall m: Map[U, V] :: { |Map_domain(m)| }
      |Map_domain(m)| == Map_card(m)
  }
  
  // The set of Values of a Map can be obtained by the function Map#Values, which is
  // defined as follows.  Remember, a Set is defined by membership (using Boogie's
  // square brackets) and Map#Card, so we need to define what these mean for the Set
  // returned by Map#Values.

  function Map_values(m: Map[U, V]): Set[V];

  axiom Map_values_def {
    forall m: Map[U, V], v: V :: { v in Map_values(m) }
      v in Map_values(m) <==>
      (exists u: U :: //{ u in Map_domain(m) } { Map_lookup(m, u) }	
        u in Map_domain(m) &&
        v == Map_lookup(m, u))
  }
  
  // // The set of Items--that is, (key,value) pairs--of a Map can be obtained by the
  // // function Map#Items.  Again, we need to define membership of Set#Card for this
  // // set.  Everywhere else in this axiomatization, Map is parameterized by types U V,
  // // even though Dafny only ever instantiates U V with Box Box.  This makes the
  // // axiomatization more generic.  Function Map#Items, however, returns a set of
  // // pairs, and the axiomatization of pairs is Dafny specific.  Therefore, the
  // // definition of Map#Items here is to be considered Dafny specific.  Also, note
  // // that it relies on the two destructors for 2-tuples.

  // function Map#Items<U,V>(Map U V) : Set Box;

  // function _System.__tuple_h2._0(DatatypeType) : Box;

  // function _System.__tuple_h2._1(DatatypeType) : Box;

  // axiom (forall<U,V> m: Map U V :: { Set#Card(Map#Items(m)) }
    // Set#Card(Map#Items(m)) == Map#Card(m));

  // axiom (forall m: Map Box Box, item: Box :: { Map#Items(m)[item] }
    // Map#Items(m)[item] <==>
      // Map#Domain(m)[_System.__tuple_h2._0($Unbox(item))] &&
      // Map#Elements(m)[_System.__tuple_h2._0($Unbox(item))] == _System.__tuple_h2._1($Unbox(item)));

  // Here are the operations that produce Map values.

  function Map_empty(): Map[U, V]
  
  axiom Map_empty_1 {
    forall u: U :: { u in Map_domain(Map_empty()) }
      !(u in Map_domain(Map_empty()))
  }
  
  axiom Map_empty_2 {
    forall m: Map[U, V] :: { Map_card(m) }
      (Map_card(m) == 0 <==> m == Map_empty()) &&
      (Map_card(m) != 0 ==> (exists u: U :: u in Map_domain(m)))
  }

  // function Map#Glue<U, V>([U] bool, [U]V, Ty): Map U V;
  // axiom (forall<U, V> a: [U] bool, b:[U]V, t:Ty ::
          // { Map#Domain(Map#Glue(a, b, t)) }
          // Map#Domain(Map#Glue(a, b, t)) == a);
  // axiom (forall<U, V> a: [U] bool, b:[U]V, t:Ty ::
          // { Map#Elements(Map#Glue(a, b, t)) }
          // Map#Elements(Map#Glue(a, b, t)) == b);
  // axiom (forall<U, V> a: [U] bool, b:[U]V, t:Ty ::
          // { $Is(Map#Glue(a, b, t), t) }
          // $Is(Map#Glue(a, b, t), t));


  //Build is used in displays, and for map updates
  function Map_build(m: Map[U, V], u: U, v: V): Map[U, V]
  
  /*axiom (forall<U, V> m: Map U V, u: U, v: V ::
    { Map#Domain(Map#Build(m, u, v))[u] } { Map#Elements(Map#Build(m, u, v))[u] }
    Map#Domain(Map#Build(m, u, v))[u] && Map#Elements(Map#Build(m, u, v))[u] == v);*/

  axiom Map_build_1 {
    forall m: Map[U, V], u1: U, u2: U, v: V :: 
      { u2 in Map_domain(Map_build(m, u1, v)) } //{ Map_elements(Map#Build(m, u, v))[u'] }
      (u2 == u1 ==> u2 in Map_domain(Map_build(m, u1, v)) /* &&
                    Map#Elements(Map#Build(m, u1, v))[u2] == v*/ &&
                    Map_lookup(Map_build(m, u1, v), u1) == v)  &&
      (u2 != u1 ==> u2 in Map_domain(Map_build(m, u1, v)) <==> u2 in Map_domain(m) /* &&
                    Map#Elements(Map#Build(m, u1, v))[u2] <==> Map#Elements(m)[u2]*/ &&
                    Map_lookup(Map_build(m, u1, v), u2) == Map_lookup(m, u2))
  }
    
  axiom Map_build_2 {
    forall m: Map[U, V], u: U, v: V :: { Map_card(Map_build(m, u, v)) }
      u in Map_domain(m) ==> Map_card(Map_build(m, u, v)) == Map_card(m)
  }
  
  axiom Map_build_3 {
    forall m: Map[U, V], u: U, v: V :: { Map_card(Map_build(m, u, v)) }
      !(u in Map_domain(m)) ==> Map_card(Map_build(m, u, v)) == Map_card(m) + 1
  }

  //equality for maps
  function Map_equal(m1: Map[U, V], m2: Map[U, V]): Bool
  
  axiom Map_equality {
    forall m1: Map[U, V], m2: Map[U, V] ::
      { Map_equal(m1, m2) }
        Map_equal(m1, m2) <==> (forall u: U :: { u in Map_domain(m1) }{ u in Map_domain(m2) } u in Map_domain(m1) <==> u in Map_domain(m2)) /*&&
                               (forall u: U :: u in Map_domain(m) ==> Map#Elements(m)[u] == Map#Elements(m')[u])*/
  }
  
  // extensionality
  axiom Map_extensionality {
    forall m1: Map[U, V], m2: Map[U, V] :: { Map_equal(m1, m2) }
      Map_equal(m1, m2) ==> m1 == m2
  }

  function Map_disjoint(m1: Map[U, V], m2: Map[U, V]): Bool
  
  axiom Map_disjoint_def {
    forall m1: Map[U, V], m2: Map[U, V]:: { Map_disjoint(m1, m2) }
      Map_disjoint(m1, m2) <==> 
      (forall u: U :: { u in Map_domain(m1) } { u in Map_domain(m2) } !(u in Map_domain(m1)) || !(u in Map_domain(m2)))
  }

  // function union<U, V>(m: map<U,V>, m': map<U,V>): map<U,V>
     // requires m !! m';
     // // ensures forall i :: i in union(m, m') <==> i in m || i in m'
     // ensures forall i :: i in union(m, m') ==> i in m.Keys + m'.Keys
     // ensures forall i :: i in union(m, m') <== i in m.Keys + m'.Keys
     // ensures forall i :: i in m ==> union(m, m')[i] == m[i];
     // ensures forall i :: i in m' ==> union(m, m')[i] == m'[i];
  // {
     // map i | i in (domain(m) + domain(m')) :: if i in m then m[i] else m'[i]
  // }  
  function Map_union(m1: Map[U, V], m2: Map[U, V]): Map[U, V]
  
  axiom Map_union_1 {
    forall m1: Map[U, V], m2: Map[U, V], u: U :: 
      { u in Map_domain(Map_union(m1, m2)) }
      { u in (Map_domain(m1) union Map_domain(m2)) }
      Map_disjoint(m1, m2) ==>
        (u in Map_domain(Map_union(m1, m2)) <==> u in (Map_domain(m1) union Map_domain(m2)))
  }
  
  axiom Map_union_2 {
    forall m1: Map[U, V], m2: Map[U, V], u: U ::
      { Map_lookup(Map_union(m1, m2), u) }
      Map_disjoint(m1, m2) && u in Map_domain(m1) ==> 
        Map_lookup(Map_union(m1, m2), u) == Map_lookup(m1, u)
  }
  
  axiom Map_union_3 {
    forall m1: Map[U, V], m2: Map[U, V], u: U ::
      { Map_lookup(Map_union(m1, m2), u) }
      Map_disjoint(m1, m2) && u in Map_domain(m2) ==> 
        Map_lookup(Map_union(m1, m2), u) == Map_lookup(m2, u)
  }
}



method test1(m: Map[Ref, Int], r: Ref, v: Int) {
  var m1: Map[Ref, Int]
  m1 := Map_build(m, r, v)
  assert r in Map_domain(m1)
  assert Map_lookup(m1, r) == v
}

method test02(r: Ref, v: Int) {
  var m0: Map[Ref, Int]
  var m1: Map[Ref, Int]
  var m2: Map[Ref, Int]
  
  // m2 := {r -> v}
  m2 := Map_build(Map_empty(), r, v)
  
  // m0 := m1 disjoint-union {r -> v}
  assume Map_disjoint(m1, m2)
  m0 := Map_union(m1, m2)
  
  assert r in Map_domain(m0)
  assert Map_lookup(m0, r) == v
}
predicate P(x: Ref)

function P_state(x: Ref): Int
  requires acc(P(x), wildcard)

predicate Q(x: Ref, n: Int)

function Q_state(x: Ref, n: Int): Int
  requires acc(Q(x, n), wildcard)

method test01(x: Ref, y: Ref, z: Ref)
  requires P(x)
  requires acc(P(y), 1/2)
  ensures P(x)
  ensures acc(P(y), 1/2)
  //ensures P_state(x) == old(P_state(x)) || P_state(y) == old(P_state(y)) // Must fail
{
  var X1: Set[Int] := Set(1, 3, 9)
  var X2: Set[Int]; inhale forall i: Int :: 0 <= i <==> i in X2

  /* Havocking all instances of P */

  label pre_exhale_1
    assert write <= perm(P(x))
    assert 1/2 <= perm(P(y))

  exhale forall r: Ref :: acc(P(r), perm(P(r)))
    assert perm(P(x)) == none
    assert perm(P(y)) == none

  inhale forall r: Ref :: acc(P(r), old[pre_exhale_1](perm(P(r))))
    assert write <= perm(P(x))
    assert 1/2 <= perm(P(y))

  // assert P_state(x) == old(P_state(x)) || P_state(y) == old(P_state(y)) // Must fail


  /* Havocking all instances of P and Q */

  var p: Perm; inhale none <= p
  inhale acc(Q(z, 0), wildcard) && acc(Q(z, 1), 1/1) && acc(Q(z, 10), 1/10) && acc(Q(z, 100), p)

  label pre_exhale_2

  exhale forall r: Ref :: acc(P(r), perm(P(r)))
  exhale forall r: Ref, i: Int :: acc(Q(r, i), perm(Q(r, i)))
    assert forall r: Ref :: none < perm(P(r)) ==> false
    assert forall r: Ref, i: Int :: none < perm(Q(r, i)) ==> false

  inhale forall r: Ref :: acc(P(r), old[pre_exhale_2](perm(P(r))))
  inhale forall r: Ref, i: Int :: acc(Q(r, i), old[pre_exhale_2](perm(Q(r, i))))

  /* Constrain the state of each held P and Q instance */
  inhale forall r: Ref :: {P_state(r)} none < perm(P(r)) ==> P_state(r) in X1
  inhale forall r: Ref, i: Int :: {Q_state(r, i)} none < perm(Q(r, i)) ==> Q_state(r, i) in X2
    assert 0 <= P_state(x) && P_state(x) <= 10
    assert 0 <= P_state(y) && P_state(y) <= 10
    assert 0 <= Q_state(z, 0)
    assert 0 <= Q_state(z, 1)
    assert 0 <= Q_state(z, 10)
    assert none < p ==> 0 <= Q_state(z, 100)

  exhale acc(Q(z, 0), wildcard) && acc(Q(z, 1), 1/1) && acc(Q(z, 10), 1/10) && acc(Q(z, 100), p)
}
region Counter(id c, int* x)
  guards { duplicable G; }
  interpretation {
    x |-> ?n && n >= 0
      // TODO: value constraints not yet assumed after region havoc, since
      //       havocked w.r.t to state function, but n >= 0 is not a
      //       postcondition of the latter
  }
  state { n }
  actions {
    // G: ?m ~> Nat; // TODO: support "forall m1, ... with p(m1, ...) ~> s(m1, ...)"
    G: 0 ~> Nat;
  }

abstract_atomic int read(id c, int* x)
  interference ?n in Nat on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n) && G@c;
  ensures ret == n;
{
  // TODO: this method cannot be verified without angelic choice

  make_atomic
    using Counter(c, x) with G@c;
  {
    update_region
      using Counter(c, x);
    {
      ret := *x;
    }
  }
}

abstract_atomic int read2(id c, int* x)
  interference ?n in Nat on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n) && G@c;
  ensures ret == n;
{
  open_region
    using Counter(c, x);
  {
    ret := *x;
  }
}

primitive_atomic bool CAS(int* x, int now, int thn)
  requires x |-> ?v;
  ensures  v == now
              ? ret && x |-> thn
              : !ret && x |-> v;

abstract_atomic void incr(id c, int* x)
  interference ?n in Nat on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n + 1) && G@c;
{
  int r;
  bool b;

  make_atomic
    using Counter(c, x) with G@c;
  {
    do
      invariant Counter(c, x);
      invariant !b ==> c |=> <D>;
      invariant  b ==> c |=> (r, r + 1);
    {
      open_region
        using Counter(c, x);
      {
        r := *x;
      }
      update_region
        using Counter(c, x);
      {
        b := CAS(x, r, r + 1);
      }
    } while (!b);
  }
}

abstract_atomic void wkincr(id c, int* x)
  interference ?n in Set[int](n) on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n + 1) && G@c;
{
  int r;

  make_atomic
    using Counter(c, x) with G@c;
  {
    open_region
      using Counter(c, x);
    {
      r := *x;
    }

    update_region
      using Counter(c, x);
    {
      *x := r + 1;
    }
  }
}

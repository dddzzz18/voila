struct node {
  int val;
  node next;

  id _next_id;
  int _next_level;
  int _next_val;
}

region Node(id r, int lvl, node n, int v)
  guards { unique OWN; }
  interpretation {
    n.val |-> v && n.next |-> ?nxt &&
    (nxt != null ==>
      n._next_id |-> ?nxt_id &&
      n._next_level |-> ?nxt_lvl &&
      n._next_val |-> ?nxt_v &&
      Node(nxt_id, nxt_lvl, nxt, nxt_v) &&
      OWN@nxt_id)
  }
  state { nxt }
  actions { ?m | OWN: null ~> m; }

procedure test01(id rr, node nn)
  requires Node(rr, 1000, nn, 0); // TODO: Workaround for issue #84
{
  node n1; id r1;
  node n2; id r2;
  node n3; id r3;


  //  n1 := new node(1, null);
  inhale n1.val |-> 1;
  inhale n1.next |-> null;
  inhale n1._next_id |-> _;
  inhale n1._next_level |-> _;
  inhale n1._next_val |-> _;

  // new Node(r1, 100, n1, 1)
  inhale OWN@r1;
//  inhale n1._next_id |-> _&& n1._next_level |-> _ && n1._next_val |-> _;
  fold Node(r1, 100, n1, 1);

//  n2 := new node(2, null);
//
//  // new Node(r2, 90, n2, 2)
//  inhale OWN@r2;
////  inhale n2._next_id |-> _ && n2._next_level |-> _ && inhale n2._next_val |-> _;
//  fold Node(r2, 90, n2, 2);

  use_atomic using Node(r1, 100, n1, 1) with OWN@r1 {
    assert n1.val |-> 1;
////    n1.val := 100;
////    n1.next := n2;
//    n1.val := 1;
  }
}

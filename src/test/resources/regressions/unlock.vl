region Lock(id a, int* x)
  guards { duplicable G; }
  interpretation {
    x |-> ?v && (v == 0 || v == 1) 
  }
  state { v }
  actions {
    G: 0 ~> Set(0, 1);
    G: 1 ~> Set(1, 0);
  }

predicate U(id a, int* x) {
  Lock(a, x, 0) && G@a
}

predicate L(id a, int* x) {
  Lock(a, x, 1) && G@a
}

void unlock(int s, id a, int* x)
  interference s in Set(1) on a;
  requires L(a, x);
  ensures U(a, x);
{
  unfold L(a, x);
  
  make_atomic
    using Lock(a, x, s) with G@a;
  {
    update_region
      using Lock(a, x, s);
    {
      *x := 0;
    }
  }
  
  fold U(a, x);
}

void unlock_wrong(int s, id a, int* x)
  interference s in Int on a;
  requires L(a, x);
  ensures U(a, x);
{
  unfold L(a, x);
  
  make_atomic
    using Lock(a, x, s) with G@a;
  {
    update_region
      using Lock(a, x, s);
    {
      *x := 0;
    }
  }
  
  fold U(a, x);
}
struct memcell {
  int f;
}

region Counter(id c, memcell x)
  guards { duplicable G; }
  interpretation {
    x.f |-> ?n
  }
  state { n }
  actions {
    G: ?m ~> Int;
  }

abstract_atomic int read01(id c, memcell x)
  interference ?n in Int on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n) && G@c;
  //:: ExpectedOutput(postcondition_error:assertion_error)
  ensures ret == n;
{
  open_region
    using Counter(c, x);
  {
    skip;
  }
}

/* TODO: See issue #22 */
//abstract_atomic int read02(id c, memcell x)
//  interference ?n in Int on c;
//  requires Counter(c, x, n) && G@c;
//  ensures ret == n;
//  //:: ExpectedOutput(postcondition_error:region_state_error)
//  ensures Counter(c, x, n) && G@c;
//{
//  open_region
//    using Counter(c, x);
//  {
//    ret := x.f;
//  }
//
//  skip;
//}

/* TODO: See issue #22 */
//abstract_atomic int read03(id c, memcell x)
//  interference ?n in Int on c;
//  requires Counter(c, x, n) && G@c;
//  ensures ret == n;
//  ensures Counter(c, x) && G@c;
//{
//  open_region
//    using Counter(c, x);
//  {
//    ret := x.f;
//  }
//
//  skip;
//}

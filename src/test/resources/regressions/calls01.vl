struct memcell {
  int f;
}

region Counter(id c, memcell x)
  guards { duplicable G; }
  interpretation {
    x.f |-> ?n
  }
  state { n }
  actions {
    G: ?n ~> ?m;
  }

abstract_atomic procedure read(id c, memcell x) returns (int ret)
  interference ?n in Int on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n) && G@c;
  ensures ret == n;
{
  open_region
    using Counter(c, x);
  {
    ret := x.f;
  }
}

procedure test01(id c, memcell x)
  requires Counter(c, x, ?n) && G@c;
{
  int v;
  v := read(c, x);
  assert v == n;
}

procedure noop(id c, memcell x)
  requires (false ==> Counter(c, x)) && G@c;
  ensures  (false ==> Counter(c, x)) && G@c;

procedure test02(id c, memcell x)
  requires Counter(c, x);
  ensures  true;
{
  //:: ExpectedOutput(precondition_error:guard_permission_error)
  noop(c, x);
}

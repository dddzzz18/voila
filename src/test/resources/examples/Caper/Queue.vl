//:: IgnoreFile(/voila/issue/0000/)


// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/Queue.t
//

//struct root {
//  node ptr;
//}

struct node {
  int value;
  node next;
  int _absstate; // ghost
  id _nextrid; // ghost
}

predicate Inv(int v)

//region Qu(id s, id rs, root h)
//  guards { duplicable G; }
//  interpretation {
//    h.ptr |-> ?x &&
//    QL(rs, x, null) //&&
////    OWN@rs
////    0 : p |-> x &*& QL(rs,x,_,3*n+1) &*& n >= 0 &*& rs@OWN;
//  }
//  state { 0 }
//  actions {}

region QL(id r, node x/*, int v */)
  guards {
    duplicable Z;
    unique OWN;
  }
  interpretation {
////                0 : x |-> v &*& (x+1) |-> 0 &*& queueInvariant(v);
////                1 : x |-> v &*& (x+1) |-> 0;
////    n > 0 | 3 * n : x |-> v &*& (x+1) |-> n &*& queueInvariant(v) &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+1 : x |-> v &*& (x+1) |-> n &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+2 : x |-> v &*& (x+1) |-> n &*& r@OWN &*& QL(rn,n,_,_);
//
// In the Caper specs, the value 'v' of the current node is part of the region arguments,
// and the value of the next node is always existentially quantified (but irrelevant, i.e. '_');
// in method specs, it is always irrelevant. That is probably to account for the fact that
// the values in the queue are never fully known due to possible concurrent modifications.
// A similar argument applies to the IDs of subsequent nodes, which are also existentially
// quantified ('rn').
//
// This kind of existential quantification, however, is not supported in Voila. Our initial
// idea of storing the values and IDs of the queue in sequence-typed region arguments,
// e.g. 'seq<int> vs' and 'seq<id> rs', and using the values for subsequent nodes, e.g.
// 'QL(head(rs), y, head(vs), tail(rs), tail(vs))' unfortunately wouldn't account for the
// concurrent nature of the queue ... at least I am not yet convinced that it would.
// Well, it probably would be if these arguments were havocked as well, which currently isn't
// the case.
//
// Solution:
//   - Store region IDs in ghost fields
//   - Remove values from region arguments until Voila has proper out-arguments
//
    (x.value |-> ?v) &&
    (x.next |-> ?y) &&
    (x._absstate |-> ?a) &&
    (x._nextrid |-> ?yr) &&
    (  a == 0     ? (Inv(v) && y == null)
     : a == 1     ? (          y == null)
     : a % 3 == 0 ? (Inv(v) && OWN@yr && QL(yr, y, a))
     : a % 3 == 1 ? (          OWN@yr && QL(yr, y, a))
     : a % 3 == 2 ? (          OWN@r  && QL(yr, y))
     : false)
  }
  state { a }
  actions {
////    n > 0  |     : 0 ~> 3*n;
    Z: 0 ~> Set(?n | n == 0 || n > 0 && n % 3 == 0);
////    n > 0  |     : 1 ~> 3*n+1;
    Z: 1 ~> Set(?n | n == 1 || n > 0 && n % 3 == 1);
////    n >= 0 | OWN : 3*n ~> 3*n+1;
    OWN: ?n if n >=0 && n % 3 == 0 ~> Set(n, n + 1);
////    n > 0  | OWN : 3*n+1 ~> 3*n+2;
    OWN: ?n if n > 0 && n % 3 == 1 ~> Set(n, n + 2);
////    n > 0  | OWN : 3*n ~> 3*n+2;
    OWN: ?n if n > 0 && n % 3 == 0 ~> Set(n, n + 2);
////    n >= 3 | OWN : 0 ~> n;
    OWN: 0 ~> Set(?n | n == 0 || n >= 3);
////    n > 0  | OWN : 1 ~> 3*n+2;
    OWN: 1 ~> Set(?n | n == 1 || n > 0 && n % 3 == 2);
  }

//head makeQueue(id r, id rs)
//  ensures Qu(r, ret, 0);
//  ensures Qu(r, rs, ret);
//{
//  node y;
//  head x;
//  // y := alloc(2);
//  inhale (y.next |-> ?n);
//
//  // [y + 1] := 0;
//  y.next := null;
//
//  // x := alloc(1);
//  inhale (x.ptr |-> ?p);
//
//  // [x] := y;
//  x.ptr := y;
//
//  // return x;
//  ret := x;
//
//
//
//
//  fold QL(rs, y, null);
////FIXME  inhale OWN@rs;
//  fold Qu(r, rs, ret, 0);
//}

node getTail(id s, node x)
  // requires QL(s, x, _, _) &*& x > 0;
  requires QL(s, x, ?a0) && x != null;
  // ensures QL(t, ret, _, _) &*& ret > 0;
  ensures QL(s, ret, ?a1) && ret != null;
    // TODO: Region id 's' is not correct
    //       Could return a struct pair (node, id)
{
  node y;
  node n;
  bool cont;

  y := x;
  cont := true;

  while (cont)
    invariant QL(s, y, ?ai) && y != null;
    invariant !cont ==> ret == y;
  {
    open_region
      using QL(s, y);
    {
      n := y.next;
    }

    if (n == null) {
      // return y;
      ret := y;
      cont := false;

      // TODO: Add "return e" statement
      //       Encode as "returnvalue := e; goto lastline"
    }

    y := n;
  }
}



// function enqueue(x, v)
//   requires Qu(r, x, 0) &*& queueInvariant(v);
//   ensures Qu(r, x, 0);
// {
//   y := alloc(2);
//   [y] := v;
//   [y + 1] := 0;
//   while (true)
//     invariant Qu(r, x, 0) &*& y |-> v &*& (y + 1) |-> 0 &*& queueInvariant(v);
//   {
//     h := [x];
//     t := getTail(h);
//     cr := CAS(t + 1, 0, y);
//     if (cr != 0) {
//       return;
//     }
//   }
// }

// function dequeue(q)
//   requires Qu(s,q,0);
//   ensures ret = 0 \/ queueInvariant(ret);
// {
//   while (true)
//     invariant Qu(s,q,0);
//   {
//     sentinel := [q];
//     head := [sentinel + 1];
//     if (head = 0) {
//       return 0;
//     } else {
//       r := CAS(q,sentinel,head);
//       if (r != 0) {
//         res := [head];
//         return res;
//       }
//     }
//   }
// }

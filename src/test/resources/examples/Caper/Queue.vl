// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/Queue.t
//

struct node {
  int value;
  node next;
  int _absstate; // ghost
  id _nextrid; // ghost
}

predicate Inv(int v)

region Qu(id s, node sentinel)
  guards { duplicable G; }
  interpretation {
////    0 : p |-> x &*& QL(rs,x,_,3*n+1) &*& n >= 0 &*& rs@OWN;
    (sentinel.next |-> ?x) &&
    (sentinel._absstate |-> ?x_a) && x_a >= 0 && x_a % 3 == 1 &&
    (sentinel._nextrid |-> ?x_r) &&
    QL(x_r, x, x_a) &&
    OWN@x_r
  }
  state { 0 }
  actions {}

region QL(id r, node x/*, int v */)
  guards {
    duplicable Z;
    unique OWN;
  }
  interpretation {
////                0 : x |-> v &*& (x+1) |-> 0 &*& queueInvariant(v);
////                1 : x |-> v &*& (x+1) |-> 0;
////    n > 0 | 3 * n : x |-> v &*& (x+1) |-> n &*& queueInvariant(v) &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+1 : x |-> v &*& (x+1) |-> n &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+2 : x |-> v &*& (x+1) |-> n &*& r@OWN &*& QL(rn,n,_,_);
//
// In the Caper specs, the value 'v' of the current node is part of the region arguments,
// and the value of the next node is always existentially quantified (but irrelevant, i.e. '_');
// in method specs, it is always irrelevant. That is probably to account for the fact that
// the values in the queue are never fully known due to possible concurrent modifications.
// A similar argument applies to the IDs of subsequent nodes, which are also existentially
// quantified ('rn').
//
// This kind of existential quantification, however, is not supported in Voila. Our initial
// idea of storing the values and IDs of the queue in sequence-typed region arguments,
// e.g. 'seq<int> vs' and 'seq<id> rs', and using the values for subsequent nodes, e.g.
// 'QL(head(rs), y, head(vs), tail(rs), tail(vs))' unfortunately wouldn't account for the
// concurrent nature of the queue ... at least I am not yet convinced that it would.
// Well, it probably would be if these arguments were havocked as well, which currently isn't
// the case.
//
// Solution:
//   - Store region IDs in ghost fields
//   - Remove values from region arguments until Voila has proper out-arguments
//
    (x.value |-> ?v) &&
    (x.next |-> ?y) &&
    (x._absstate |-> ?a) &&
    (x._nextrid |-> ?y_r) &&
    (  a == 0     ? (Inv(v) && y == null)
     : a == 1     ? (          y == null)
     : a % 3 == 0 ? (Inv(v) && OWN@y_r && QL(y_r, y, a))
     : a % 3 == 1 ? (          OWN@y_r && QL(y_r, y, a))
     : a % 3 == 2 ? (          OWN@r   && QL(y_r, y))
     : false)
  }
  state { a }
  actions {
////    n > 0  |     : 0 ~> 3*n;
    Z: 0 ~> Set(?n | n == 0 || n > 0 && n % 3 == 0);
////    n > 0  |     : 1 ~> 3*n+1;
    Z: 1 ~> Set(?n | n == 1 || n > 0 && n % 3 == 1);
////    n >= 0 | OWN : 3*n ~> 3*n+1;
    OWN: ?n if n >=0 && n % 3 == 0 ~> Set(n, n + 1);
////    n > 0  | OWN : 3*n+1 ~> 3*n+2;
    OWN: ?n if n > 0 && n % 3 == 1 ~> Set(n, n + 2);
////    n > 0  | OWN : 3*n ~> 3*n+2;
    OWN: ?n if n > 0 && n % 3 == 0 ~> Set(n, n + 2);
////    n >= 3 | OWN : 0 ~> n;
    OWN: 0 ~> Set(?n | n == 0 || n >= 3);
////    n > 0  | OWN : 1 ~> 3*n+2;
    OWN: 1 ~> Set(?n | n == 1 || n > 0 && n % 3 == 2);
  }

//head makeQueue(id r, id rs)
//  ensures Qu(r, ret, 0);
//  ensures Qu(r, rs, ret);
//{
//  node y;
//  head x;
//  // y := alloc(2);
//  inhale (y.next |-> ?n);
//
//  // [y + 1] := 0;
//  y.next := null;
//
//  // x := alloc(1);
//  inhale (x.ptr |-> ?p);
//
//  // [x] := y;
//  x.ptr := y;
//
//  // return x;
//  ret := x;
//
//
//
//
//  fold QL(rs, y, null);
////FIXME  inhale OWN@rs;
//  fold Qu(r, rs, ret, 0);
//}

procedure getTail(id r, node x) returns (node y, id y_r) // y_r is ghost
  requires QL(r, x, ?x_a) && x != null;
  ensures QL(y_r, y, ?y_a) && y != null;
{
  node n;
  bool cont;

  y := x;

  // ghost assignment to y_r
  havoc y_r;
  assume y_r == r;

  cont := true;

  while (cont)
    invariant QL(y_r, y) && y != null;
  {
    open_region
      using QL(y_r, y);
    {
      n := y.next;

      // Ghost code
      assert y._nextrid |-> ?n_r; // Let n_s be the region id of the next node
      assert n != null ==> QL(n_r, n); // If next node exist, we should hold QL(n_s, n)
      inhale n != null ==> QL(n_r, n); // In this case, duplicate the region assertion
    }

    if (n == null) {
      // return y;
      cont := false;
    } else {
      y := n;

      // ghost assignment to y_r
      havoc y_r;
      assume y_r == n_r;
    }
  }
}



// function enqueue(x, v)
//   requires Qu(r, x, 0) &*& queueInvariant(v);
//   ensures Qu(r, x, 0);
// {
//   y := alloc(2);
//   [y] := v;
//   [y + 1] := 0;
//   while (true)
//     invariant Qu(r, x, 0) &*& y |-> v &*& (y + 1) |-> 0 &*& queueInvariant(v);
//   {
//     h := [x];
//     t := getTail(h);
//     cr := CAS(t + 1, 0, y);
//     if (cr != 0) {
//       return;
//     }
//   }
// }

// function dequeue(q)
//   requires Qu(s,q,0);
//   ensures ret = 0 \/ queueInvariant(ret);
// {
//   while (true)
//     invariant Qu(s,q,0);
//   {
//     sentinel := [q];
//     head := [sentinel + 1];
//     if (head = 0) {
//       return 0;
//     } else {
//       r := CAS(q,sentinel,head);
//       if (r != 0) {
//         res := [head];
//         return res;
//       }
//     }
//   }
// }

// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/Queue.t
//

struct node {
  int value;
  node next;
  int _absstate; // ghost
  id _nextrid; // ghost
}

predicate Inv(int v)

region Qu(id s, node sentinel)
  guards { duplicable G; }
  interpretation {
////    0 : p |-> x &*& QL(rs,x,_,3*n+1) &*& n >= 0 &*& rs@OWN;
    (sentinel.next |-> ?x) && x != null &&
    (sentinel._absstate |-> ?x_a) && x_a >= 0 && x_a % 3 == 1 &&
    (sentinel._nextrid |-> ?x_r) &&
    QL(x_r, x, x_a) &&
    OWN@x_r
  }
  state { 0 }
  actions {}

region QL(id r, node x/*, int v */)
  guards {
    duplicable Z;
    unique OWN;
  }
  interpretation {
////                0 : x |-> v &*& (x+1) |-> 0 &*& queueInvariant(v);
////                1 : x |-> v &*& (x+1) |-> 0;
////    n > 0 | 3 * n : x |-> v &*& (x+1) |-> n &*& queueInvariant(v) &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+1 : x |-> v &*& (x+1) |-> n &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+2 : x |-> v &*& (x+1) |-> n &*& r@OWN &*& QL(rn,n,_,_);
//
// In the Caper specs, the value 'v' of the current node is part of the region arguments,
// and the value of the next node is always existentially quantified (but irrelevant, i.e. '_');
// in method specs, it is always irrelevant. That is probably to account for the fact that
// the values in the queue are never fully known due to possible concurrent modifications.
// A similar argument applies to the IDs of subsequent nodes, which are also existentially
// quantified ('rn').
//
// This kind of existential quantification, however, is not supported in Voila. Our initial
// idea of storing the values and IDs of the queue in sequence-typed region arguments,
// e.g. 'seq<int> vs' and 'seq<id> rs', and using the values for subsequent nodes, e.g.
// 'QL(head(rs), y, head(vs), tail(rs), tail(vs))' unfortunately wouldn't account for the
// concurrent nature of the queue ... at least I am not yet convinced that it would.
// Well, it probably would be if these arguments were havocked as well, which currently isn't
// the case.
//
// Solution:
//   - Store region IDs in ghost fields
//   - Remove values from region arguments until Voila has proper out-arguments
//
    (x.value |-> ?v) &&
    (x.next |-> ?y) &&
    (x._absstate |-> ?a) &&
    (x._nextrid |-> ?y_r) &&
    (  a == 0               ? (Inv(v) && y == null)
     : a == 1               ? (          y == null)
     : /* a >= 3 && */ a % 3 == 0 ? (Inv(v) && OWN@y_r && QL(y_r, y/*, a*/) && y != null)
     : /* a >= 4 && */ a % 3 == 1 ? (          OWN@y_r && QL(y_r, y/*, a*/) && y != null)
     : /* a >= 5 && */ a % 3 == 2 ? (          OWN@r   && QL(y_r, y)    && y != null)
     : false)
  }
  state { a }
  actions {
////    n > 0  |     : 0 ~> 3*n;
    Z: 0 ~> Set(?n | n == 0 || n > 0 && n % 3 == 0);
////    n > 0  |     : 1 ~> 3*n+1;
    Z: 1 ~> Set(?n | n == 1 || n > 0 && n % 3 == 1);
////    n >= 0 | OWN : 3*n ~> 3*n+1;
    OWN: ?n if n >=0 && n % 3 == 0 ~> Set(n, n + 1);
////    n > 0  | OWN : 3*n+1 ~> 3*n+2;
    OWN: ?n if n > 0 && n % 3 == 1 ~> Set(n, n + 2);
////    n > 0  | OWN : 3*n ~> 3*n+2;
    OWN: ?n if n > 0 && n % 3 == 0 ~> Set(n, n + 2);
////    n >= 3 | OWN : 0 ~> n;
    OWN: 0 ~> Set(?n | n == 0 || n >= 3);
////    n > 0  | OWN : 1 ~> 3*n+2;
    OWN: 1 ~> Set(?n | n == 1 || n > 0 && n % 3 == 2);
  }

//head makeQueue(id r, id rs)
//  ensures Qu(r, ret, 0);
//  ensures Qu(r, rs, ret);
//{
//  node y;
//  head x;
//  // y := alloc(2);
//  inhale (y.next |-> ?n);
//
//  // [y + 1] := 0;
//  y.next := null;
//
//  // x := alloc(1);
//  inhale (x.ptr |-> ?p);
//
//  // [x] := y;
//  x.ptr := y;
//
//  // return x;
//  ret := x;
//
//
//
//
//  fold QL(rs, y, null);
////FIXME  inhale OWN@rs;
//  fold Qu(r, rs, ret, 0);
//}

procedure getTail(id r, node x) returns (node y, id y_r) // y_r is ghost
  requires QL(r, x) && x != null;
  ensures  QL(y_r, y) && y != null;
//  ensures  QL(r, x);
    // Should also hold, but requires a stronger loop invariant and additional annotations
{
  node n;
  bool cont;

assume false;

  y := x;

  // ghost assignment to y_r
  havoc y_r;
  assume y_r == r;

  cont := true;

  while (cont)
    invariant QL(y_r, y) && y != null;
  {
    open_region
      using QL(y_r, y);
    {
      n := y.next;

      // Ghost code
      assert y._nextrid |-> ?n_r; // Let n_s be the region id of the next node
      assert n != null ==> QL(n_r, n); // If next node exist, we should hold QL(n_s, n)
      inhale n != null ==> QL(n_r, n); // In this case, duplicate the region assertion
    }

    if (n == null) {
      // return y;
      cont := false;
    } else {
      y := n;

      // ghost assignment to y_r
      havoc y_r;
      assume y_r == n_r;
    }
  }
}

procedure enqueue(id s, node x, int v)
  requires Qu(s, x, 0) && Inv(v);
  ensures  Qu(s, x, 0); // Caper's original specs, weak and trivial to satisfy
  // ensures false; // TODO: Crashes Silicon - find out, why
{
  node y;
  node h;
  node t;
  id y_r; // ghost
  id t_r; // ghost
  bool b;
  bool cont;

//  y := alloc(2);
  inhale y.value |-> ?_u0; // TODO: Support wildcards, see issue #11
  inhale y.next |-> ?_u1;
  inhale y._nextrid |-> ?_u2;  // ghost
  inhale y._absstate |-> 0; // ghost: Choose abstract state of newly-allocated node region
  havoc y_r; // ghost
  inhale OWN@y_r; // ghost: Gain new node's guard

//  [y] := v;
//  [y + 1] := 0;
  y.value := v;
  y.next := null;
  fold QL(y_r, y, -123456789); // TODO: Fix issue (value ignored) // ghost: Close newly-allocated region

  cont := true;

  while (cont)
    invariant Qu(s, x, 0);
//    invariant cont ==> (y.value |-> v) && (y.next |-> null) && Inv(v);
    invariant cont ==> QL(y_r, y) && OWN@y_r;
  {
//    h := [x];
    open_region
      using Qu(s, x);
    {
      h := x.next; // Get pointer to first queue node (sentinel.next)

      assert x._nextrid |-> ?h_r; // ghost: Bind first queue node's region id
      assert QL(h_r, h); // ghost: Show that QL(h_r, h) is accessible ...
      inhale QL(h_r, h); // ghost: ... and duplicate the region assertion
    }

//    t := getTail(h);
    t, t_r := getTail(h_r, h);

//    cr := CAS(t + 1, 0, y);
    use_atomic
      using QL(t_r, t) with Z@t_r;
    {
      b := CAS_next(t, null, y); // Try to append new node to tail

      // If append succeeded, perform various ghost operations
      if (b) {
        assert t._absstate |-> ?t_a0; // ghost: Bind previous tail's abstract state
        assert t_a0 == 0 || t_a0 == 1; // ghost: State was in one of two states
        exhale t._absstate |-> t_a0; // ghost: Havoc abstract state
        inhale t._absstate |-> ?t_a1; // ghost
        assume t_a1 >= 3; // ghost
        assume t_a0 == 0 ==> t_a1 % 3 == 0; // ghost: Choose new abstract state ...
        assume t_a0 == 1 ==> t_a1 % 3 == 1; // ghost: ... depending on previous state
        exhale t._nextrid |-> ?_u10; // ghost: Havoc next region's id ...
        inhale t._nextrid |-> y_r; // ghost: ... and set to y_r
      }
    }

//    if (cr != 0) {
//      return;
//    }
    if (b) {
      cont := false;
    }
  }
}




// function dequeue(q)
//   requires Qu(s,q,0);
//   ensures ret = 0 \/ queueInvariant(ret);
// {
//   while (true)
//     invariant Qu(s,q,0);
//   {
//     sentinel := [q];
//     head := [sentinel + 1];
//     if (head = 0) {
//       return 0;
//     } else {
//       r := CAS(q,sentinel,head);
//       if (r != 0) {
//         res := [head];
//         return res;
//       }
//     }
//   }
// }



primitive_atomic procedure CAS_next(node x, node now, node thn) returns (bool ret)
  requires x.next |-> ?v;
  ensures  v == now
              ? ret && x.next |-> thn
              : !ret && x.next |-> v;

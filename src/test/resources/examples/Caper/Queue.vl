//:: IgnoreFile(/voila/issue/41/)

// TODO: Currently (nondeterministically?) crashes Silicon - find out, why

// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/Queue.t
//

struct queue {
  node sentinel;
  id _nextrid; // ghost
}

struct node {
  int value;
  node next;
  int _absstate; // ghost
  id _nextrid; // ghost
}

predicate Inv(int v)

region Qu(id q_r, queue q)
  guards { duplicable G; }
  interpretation {
////    0 : p |-> x &*& QL(rs,x,_,3*n+1) &*& n >= 0 &*& rs@OWN;
    q.sentinel |-> ?sl && sl != null &&
//    sentinel._absstate |-> ?x_a && x_a >= 0 && x_a % 3 == 1 &&
    q._nextrid |-> ?sl_r &&
    QL(sl_r, sl, ?sl_a) && sl_a >= 0 && sl_a % 3 == 1 &&
    OWN@sl_r
  }
  state { 0 }
  actions {}

region QL(id r, node x/*, int v */) // TODO: Add v as an out-argument
  guards {
    duplicable Z;
    unique OWN;
  }
  interpretation {
////                0 : x |-> v &*& (x+1) |-> 0 &*& queueInvariant(v);
////                1 : x |-> v &*& (x+1) |-> 0;
////    n > 0 | 3 * n : x |-> v &*& (x+1) |-> n &*& queueInvariant(v) &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+1 : x |-> v &*& (x+1) |-> n &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+2 : x |-> v &*& (x+1) |-> n &*& r@OWN &*& QL(rn,n,_,_);
//
// In the Caper specs, the value 'v' of the current node is part of the region arguments,
// and the value of the next node is always existentially quantified (but irrelevant, i.e. '_');
// in method specs, it is always irrelevant. That is probably to account for the fact that
// the values in the queue are never fully known due to possible concurrent modifications.
// A similar argument applies to the IDs of subsequent nodes, which are also existentially
// quantified ('rn').
//
// This kind of existential quantification, however, is not supported in Voila. Our initial
// idea of storing the values and IDs of the queue in sequence-typed region arguments,
// e.g. 'seq<int> vs' and 'seq<id> rs', and using the values for subsequent nodes, e.g.
// 'QL(head(rs), y, head(vs), tail(rs), tail(vs))' unfortunately wouldn't account for the
// concurrent nature of the queue ... at least I am not yet convinced that it would.
// Well, it probably would be if these arguments were havocked as well, which currently isn't
// the case.
//
// Solution:
//   - Store region IDs in ghost fields
//   - Remove values from region arguments until Voila has proper out-arguments
//
    (x.value |-> ?v) &&
    (x.next |-> ?y) &&
    (x._absstate |-> ?a) &&
    (x._nextrid |-> ?y_r) &&
    (  a == 0               ? (Inv(v) && y == null)
     : a == 1               ? (          y == null)
     : a >= 3 && a % 3 == 0 ? (Inv(v) && OWN@y_r && QL(y_r, y, ?y_a) && y_a % 3 == 0 && y != null)
     : a >= 4 && a % 3 == 1 ? (          OWN@y_r && QL(y_r, y, ?y_b) && y_b % 3 == 0 && y != null) // TODO: Binding a_y again here results in duplicated identifiers
     : a >= 5 && a % 3 == 2 ? (          OWN@r   && QL(y_r, y)                       && y != null)
     : false)
  }
  state { a }
  actions {
/* TODO: Overlapping actions are not yet supported (issue #27).
 *       Currently, the actions are turned into a cascade of ite-expressions,
 *       starting with the last one.
 *       Note: The current order is crucial for verifying the example!
 */
////    n >= 3 | OWN : 0 ~> n;
    OWN: 0 ~> Set(?n | n == 0 || n >= 3);
////    n > 0  | OWN : 1 ~> 3*n+2;
    OWN: 1 ~> Set(?n | n == 1 || n > 0 && n % 3 == 2);

////    n > 0  |     : 0 ~> 3*n;
    Z: 0 ~> Set(?n | n == 0 || n > 0 && n % 3 == 0);
////    n > 0  |     : 1 ~> 3*n+1;
    Z: 1 ~> Set(?n | n == 1 || n > 0 && n % 3 == 1);

////    n >= 0 | OWN : 3*n ~> 3*n+1;
    OWN: ?n if n >=0 && n % 3 == 0 ~> Set(n, n + 1);
////    n > 0  | OWN : 3*n+1 ~> 3*n+2;
    OWN: ?n if n > 0 && n % 3 == 1 ~> Set(n, n + 1);
////    n > 0  | OWN : 3*n ~> 3*n+2;
    OWN: ?n if n > 0 && n % 3 == 0 ~> Set(n, n + 2);
  }

procedure makeQueue() returns (id r, queue ret)
  ensures Qu(r, ret, 0);
{
  queue x;
  node y;
  id rs; // ghost

  // y := alloc(2);
  inhale y.value |-> _;
  inhale y.next |-> _;

  // [y + 1] := 0;
  y.next := null;

  // x := alloc(1);
  inhale x.sentinel |-> _;

  // [x] := y;
  x.sentinel := y;

  // return x;
  ret := x;

  inhale y._nextrid |-> _; // ghost
  inhale y._absstate |-> 1; // ghost
  inhale OWN@rs; // ghost
  fold QL(rs, y); // ghost: Close newly-allocated region

  inhale x._nextrid|-> rs; // ghost
  fold Qu(r, ret); // ghost: Close newly-allocated region
}

procedure getTail(id r, node x) returns (node y, id y_r) // y_r is ghost
  requires QL(r, x) && x != null;
  ensures  QL(y_r, y) && y != null;
{
  node n;
  bool cont;

  y := x;

  // ghost assignment to y_r
  havoc y_r;
  assume y_r == r;

  cont := true;

  while (cont)
    invariant QL(y_r, y) && y != null;
  {
    open_region
      using QL(y_r, y);
    {
      n := y.next;

      // Ghost code
      assert y._nextrid |-> ?n_r; // Let n_r be the region id of the next node
      assert n != null ==> QL(n_r, n); // If next node exist, we should hold QL(n_r, n)
      inhale n != null ==> QL(n_r, n); // In this case, duplicate the region assertion
    }

    if (n == null) {
      // return y;
      cont := false;
    } else {
      y := n;

      // ghost assignment to y_r
      havoc y_r;
      assume y_r == n_r;
    }
  }
}

procedure enqueue(id s, queue x, int v)
  requires Qu(s, x, 0) && Inv(v);
  ensures  Qu(s, x, 0); // Caper's original specs, weak and trivial to satisfy
{
  node y;
  node h;
  node t;
  id y_r; // ghost
  id t_r; // ghost
  bool b;
  bool cont;

//  y := alloc(2);
  inhale y.value |-> _;
  inhale y.next |-> _;

//  [y] := v;
//  [y + 1] := 0;
  y.value := v;
  y.next := null;

  cont := true;

  while (cont)
    invariant Qu(s, x, 0);
    invariant cont ==> y.value |-> v && y.next |-> null && Inv(v);
  {
//    h := [x];
    open_region
      using Qu(s, x);
    {
      h := x.sentinel;

      assert x._nextrid |-> ?h_r; // ghost: Bind first queue node's region id
      assert QL(h_r, h); // ghost: Show that QL(h_r, h) is accessible ...
      inhale QL(h_r, h); // ghost: ... and duplicate the region assertion
    }

//    t := getTail(h);
    t, t_r := getTail(h_r, h);

//    cr := CAS(t + 1, 0, y);
    use_atomic
      using QL(t_r, t) with Z@t_r;
    {
      b := CAS_next(t, null, y); // Try to append new node to tail

      // If append succeeded, perform various ghost operations
      if (b) {
        inhale y._nextrid |-> _;
        inhale y._absstate |-> 0; // Choose abstract state of newly-allocated node region
        havoc y_r;
        inhale OWN@y_r; // Gain new node's guard
        fold QL(y_r, y); // Close newly-allocated region

        assert t._absstate |-> ?t_a0; // Bind previous tail's abstract state
        assert t_a0 == 0 || t_a0 == 1; // State was in one of two states
        exhale t._absstate |-> t_a0; // Havoc abstract state
        inhale t._absstate |-> ?t_a1;
        assume t_a1 >= 3;
        assume t_a0 == 0 ==> t_a1 % 3 == 0; // Choose new abstract state ...
        assume t_a0 == 1 ==> t_a1 % 3 == 1; // ... depending on previous state
        exhale t._nextrid |-> _;   // Havoc next region's id ...
        inhale t._nextrid |-> y_r; // ... and set to y_r
      }
    }

//    if (cr != 0) {
//      return;
//    }
    if (b) {
      cont := false;
    }
  }
}

procedure dequeue(id q_r, queue q) returns (bool success, int v)
  requires Qu(q_r, q, 0);
  ensures  success ==> Inv(v);
{
  node sl;
  node hd;
  bool done;

  done := false;
  success := false;

  while (!done)
    invariant Qu(q_r, q, 0);
    invariant success ==> Inv(v);
//    invariant success ==> false;
  {
//    sentinel := [q];
    open_region
      using Qu(q_r, q);
    {
      sl := q.sentinel;
      // ghost: Duplicate sentinel's region assertion
      assert q._nextrid |-> ?sl_r0;
      assert QL(sl_r0, sl, ?sl_a0);
      inhale QL(sl_r0, sl);
      assert sl_a0 >= 0;     // REMOVE
      assert sl_a0 % 3 == 1; // REMOVE
    }

//    head := [sentinel + 1];
    open_region
      using QL(sl_r0, sl);
    {
      hd := sl.next;
      // ghost: If head present, duplicate its region assertion
      if (hd != null) {
        assert sl._nextrid |-> ?hd_r0;
        assert QL(hd_r0, hd, ?hd_a0);
        inhale QL(hd_r0, hd);
      }
    }

    if (hd == null) {
//      return 0;
      done := true;
      success := false;
    } else {
//      r := CAS(q, sentinel, hd);
      use_atomic
        using Qu(q_r, q) with G@q_r;
      {
        assert q._nextrid |-> ?sl_r1;
        assert q.sentinel |-> ?sl1;
        assert QL(sl_r1, sl1, ?sl_a1);

        (
          success := CAS_sentinel(q, sl, hd);
          // If dequeue succeeded, perform various ghost operations
          if (success) {
            // Since the CAS succeeded, q.sentinel was sl before the CAS.
            assert sl1 == sl;
            assume sl_r1 == sl_r0; // TODO: Implied by sl1 == sl
            assert sl_a1 >= 0;
            assert sl_a1 % 3 == 1;

            exhale q._nextrid |-> _;
            inhale q._nextrid |-> hd_r0;

            exhale QL(sl_r0, sl); // TODO: We hold two copies of QL(sl_r0, sl). In order to
                                  //       prevent contradictions between the two ...

            use_atomic
              using QL(sl_r0, sl) with OWN@sl_r0;
            {
              assert sl.next |-> ?hd1;
              if (hd1 != hd) {
                assume false;
                  // TODO: Provable in Caper (i.e. unreachable), but not in Voila.
                  //
                  // My current understanding is the following: without knowing that sentinel
                  // still precedes head we won't get OWN for head out of the sentinel (we would
                  // get it for some other node), which in turn would prevent us from changing
                  // the abstract state of the head region, which we need in order to take the
                  // invariant out of the region.
                  //
                  // I believe that Caper can prove that the sentinel's successor cannot have
                  // changed in the meantime because the action used there effectively disallow
                  // changing the next pointer once it is non-null.
              }

              assert sl._nextrid |-> ?hd_r1;
              assume hd_r1 == hd_r0; // TODO: Implied by hd1 == hd

              assert sl_a1 % 3 == 1;
              assert sl_a1 >= 4;
              exhale sl._absstate |-> sl_a1;
              inhale sl._absstate |-> sl_a1 + 1;
              assert (sl_a1 + 1) >= 5;
              assert (sl_a1 + 1) % 3 == 2;

              exhale QL(hd_r0, hd); // TODO: We hold two copies of QL(hd_r0, hd) ...

              use_atomic
                using QL(hd_r0, hd) with OWN@hd_r0;
              {
                assert hd.value |-> ?v0;
                assert hd._absstate |-> ?u40;
                assert u40 % 3 == 0;
                assert u40 == 0 || u40 >= 3;
                assert Inv(v0);
                assume u40 == 0; // TODO: Get rid of (case split?) Could also be a non-issue once overlapping actions are supported.
                exhale hd._absstate |-> u40;
                inhale hd._absstate |-> u40 + 1;
              }

              // Duplicate region assertion
              assert QL(hd_r0, hd);
              inhale QL(hd_r0, hd);
            }
          }
        );

//        if (r != 0)
        if (success) {
//          res := [head];
//          return res;
          open_region
            using QL(hd_r0, hd);
          {
            v := hd.value;
            assume v == v0; // TODO: Holds in Caper because hd.value is immutable
          }
        }
      }
    }
  }
}



primitive_atomic procedure CAS_next(node x, node now, node thn) returns (bool ret)
  requires x.next |-> ?v;
  ensures  v == now
              ? ret && x.next |-> thn
              : !ret && x.next |-> v;

primitive_atomic procedure CAS_sentinel(queue x, node now, node thn) returns (bool ret)
  requires x.sentinel |-> ?v;
  ensures  v == now
              ? ret && x.sentinel |-> thn
              : !ret && x.sentinel |-> v;

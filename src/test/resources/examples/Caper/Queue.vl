// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/Queue.t
//

struct queue {
  node sentinel;
}

struct node {
  int value;
  node next;
}

predicate Inv(int v)

region Qu(id q_r, int q_lvl, queue q)
  ghost_fields {
    id _sentinel_id;
    int _sentinel_level;
  }
  guards { duplicable G; }
  interpretation {
////    0 : p |-> x &*& QL(rs,x,_,3*n+1) &*& n >= 0 &*& rs@OWN;
    q.sentinel |-> ?sl && sl != null &&
//    sentinel._absstate |-> ?x_a && x_a >= 0 && x_a mod 3 == 1 &&
    q_r._sentinel_id |-> ?sl_r &&
    q_r._sentinel_level |-> ?sl_lvl && sl_lvl < q_lvl &&
    QL(sl_r, sl_lvl, sl, ?sl_a) && sl_a >= 0 && sl_a mod 3 == 1 &&
    OWN@sl_r
  }
  state { 0 }
  actions {}


//:: UnexpectedOutput(region_actions_not_transitive_error)
region QL(id r, int lvl, node x/*, int v */) // TODO: Add v as an in-argument, see also BagStack-inargs.vl
  ghost_fields {
    int _absstate;
    id _next_id;
    int _next_level;
  }
  guards {
    duplicable Z;
    unique OWN;
  }
  interpretation {
////                0 : x |-> v &*& (x+1) |-> 0 &*& queueInvariant(v);
////                1 : x |-> v &*& (x+1) |-> 0;
////    n > 0 | 3 * n : x |-> v &*& (x+1) |-> n &*& queueInvariant(v) &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+1 : x |-> v &*& (x+1) |-> n &*& QL(rn,n,_,3*b) &*& rn@OWN;
////    n > 0 | 3*n+2 : x |-> v &*& (x+1) |-> n &*& r@OWN &*& QL(rn,n,_,_);
//
// In the Caper specs, the value 'v' of the current node is part of the region arguments,
// and the value of the next node is always existentially quantified (but irrelevant, i.e. '_');
// in method specs, it is always irrelevant. That is probably to account for the fact that
// the values in the queue are never fully known due to possible concurrent modifications.
// A similar argument applies to the IDs of subsequent nodes, which are also existentially
// quantified ('rn').
//
// This kind of existential quantification, however, is not supported in Voila. Our initial
// idea of storing the values and IDs of the queue in sequence-typed region arguments,
// e.g. 'seq<int> vs' and 'seq<id> rs', and using the values for subsequent nodes, e.g.
// 'QL(head(rs), y, head(vs), tail(rs), tail(vs))' unfortunately wouldn't account for the
// concurrent nature of the queue ... at least I am not yet convinced that it would.
// Well, it probably would be if these arguments were havocked as well, which currently isn't
// the case.
//
// Solution:
//   - Store region IDs in ghost fields
//   - Remove values from region arguments until Voila has proper out-arguments
//
    (x.value |-> ?v) &&
    (x.next |-> ?y) &&
    (r._absstate |-> ?a) &&
    (r._next_id |-> ?y_r) &&
    (r._next_level |-> ?y_lvl) &&
    (y == null || y_lvl < lvl) && // Level constraint irrelevant if y == null
    (  a == 0               ? (Inv(v) && y == null)
     : a == 1               ? (          y == null)
     : a >= 3 && a mod 3 == 0 ? (Inv(v) && OWN@y_r && QL(y_r, y_lvl, y, ?y_a) && y_a mod 3 == 0 && y != null)
     : a >= 4 && a mod 3 == 1 ? (          OWN@y_r && QL(y_r, y_lvl, y, ?y_b) && y_b mod 3 == 0 && y != null) // TODO: Binding a_y again here results in duplicated identifiers
     : a >= 5 && a mod 3 == 2 ? (          OWN@r   && QL(y_r, y_lvl, y)                       && y != null)
     : false)
  }
  state { a }
  actions {
/* TODO: Overlapping actions are not yet supported (issue #27).
 *       Currently, the actions are turned into a cascade of ite-expressions,
 *       starting with the last one.
 *       Note: The current order is crucial for verifying the example!
 */
////    n >= 3 | OWN : 0 ~> n;
    ?n | n >= 3                | OWN: 0 ~> n;
////    n > 0  | OWN : 1 ~> 3*n+2;
    ?n | n > 0 && n mod 3 == 2 | OWN: 1 ~> n;

////    n > 0  |     : 0 ~> 3*n;
    ?n | n > 0 && n mod 3 == 0 | Z:   0 ~> n;
////    n > 0  |     : 1 ~> 3*n+1;
    ?n | n > 0 && n mod 3 == 1 | Z:   1 ~> n;

////    n >= 0 | OWN : 3*n ~> 3*n+1;
    ?n | n >=0 && n mod 3 == 0 | OWN: n ~> n + 1;
////    n > 0  | OWN : 3*n+1 ~> 3*n+2;
    ?n | n > 0 && n mod 3 == 1 | OWN: n ~> n + 1;
////    n > 0  | OWN : 3*n ~> 3*n+2;
    ?n | n > 0 && n mod 3 == 0 | OWN: n ~> n + 2;
  }

procedure makeQueue() returns (id r, int lvl, queue ret)
  ensures Qu(r, lvl, ret, 0);
{
  queue x;
  node y;
  id rs; // ghost
  int rlvl; // ghost

//  y := alloc(2);
//  [y + 1] := 0;
  y := new node();
  y.next := null;

//  x := alloc(1);
//  [x] := y;
  x := new queue(y);

//  return x;
  ret := x;

  // Create region QL(rs, ...)
  rs := new QL(rlvl, y) with OWN {
    rs._absstate := 1;
  }

  // Create region Qu(r, ...)
  r := new Qu(lvl, ret) {
    r._sentinel_id := rs;
    r._sentinel_level := rlvl;
    assume 0 <= rlvl < lvl;
  }
}

procedure getTail(id r, int lvl, node x) returns (node y, id y_r, int y_lvl) // y_r and y_lvl are ghost
  requires QL(r, lvl, x) && x != null;
  ensures  QL(y_r, y_lvl, y) && y != null;
  ensures  y_lvl <= lvl;
{
  node n;
  bool cont;

  y := x;

  // Ghost code assignments to y_r and y_lvl
  havoc y_r;   assume y_r == r;
  havoc y_lvl; assume y_lvl == lvl;

  cont := true;

  while (cont)
    invariant QL(y_r, y_lvl, y) && y != null;
    invariant y_lvl <= lvl;
  {
    open_region
      using QL(y_r, y_lvl, y);
    {
      n := y.next;

      // Ghost code
      assert y_r._next_id |-> ?n_r; // Let n_r be the region id of the next node
      assert y_r._next_level |-> ?n_lvl; // Let n_lvl be the region lvl of the next node
      assert n != null ==> QL(n_r, n_lvl, n); // If next node exist, we should hold QL(n_r, n_lvl, n)
      inhale n != null ==> QL(n_r, n_lvl, n); // In this case, duplicate the region assertion
    }

    if (n == null) {
//      return y;
      cont := false;
    } else {
      y := n;

      // Ghost code assignments to y_r and y_lvl
      havoc y_r;   assume y_r == n_r;
      havoc y_lvl; assume y_lvl == n_lvl;
    }
  }
}

procedure enqueue(id s, int lvl, queue x, int v)
  requires Qu(s, lvl, x, 0) && Inv(v);
  ensures  Qu(s, lvl, x, 0);
{
  node y;
  node h;
  node t;
  id y_r; // ghost
  int y_lvl; // ghost
  id t_r; // ghost
  int t_lvl; // ghost
  bool b;
  bool cont;

//  y := alloc(2);
//  [y] := v;
//  [y + 1] := 0;
  y := new node(v, null);

  cont := true;

  while (cont)
    invariant Qu(s, lvl, x, 0);
    invariant cont ==> y.value |-> v && y.next |-> null && Inv(v);
  {
//    h := [x];
    open_region
      using Qu(s, lvl, x);
    {
      h := x.sentinel;

      assert s._sentinel_id |-> ?h_r; // ghost: Bind first queue node's region id
      assert s._sentinel_level |-> ?h_lvl; // ghost: Bind first queue node's region lvl
      assert QL(h_r, h_lvl, h); // ghost: Show that QL(h_r, h_lvl, h) is accessible ...
      inhale QL(h_r, h_lvl, h); // ghost: ... and duplicate the region assertion
    }

//    t := getTail(h);
    t, t_r, t_lvl := getTail(h_r, h_lvl, h);

    inhale Z@t_r; // QL's Z guard is duplicable

//    cr := CAS(t + 1, 0, y);
    use_atomic
      using QL(t_r, t_lvl, t) with Z@t_r;
    {
      b := CAS_next(t, null, y); // Try to append new node to tail

      // If append succeeded, perform various ghost operations
      if (b) {
        // Create region QL(y_r, ...)
        y_r := new QL(y_lvl, y) with OWN {
          y_r._absstate := 0;
          havoc y_lvl; assume 0 < y_lvl < t_lvl; // TODO: This constraint actually requires a dense level order
        }

        assert t_r._absstate |-> ?t_a0; // Bind previous tail's abstract state
        assert t_a0 == 0 || t_a0 == 1; // [DEBUG] State was in one of two states
        t_r._absstate := t_a0 == 0 ? 3 : 4; // Choose new abstract state, depending on previous state

        // Update t_r's remaining ghost fields to match the new tail y
        t_r._next_id := y_r;
        t_r._next_level := y_lvl;
      }
    }

//    if (cr != 0) {
//      return;
//    }
    if (b) {
      cont := false;
    }
  }
}

procedure dequeue(id q_r, int q_lvl, queue q) returns (bool success, int v)
  requires Qu(q_r, q_lvl, q, 0);
  ensures  success ==> Inv(v);
{
  node sl;
  node hd;
  bool done;

  done := false;
  success := false;

  while (!done)
    invariant Qu(q_r, q_lvl, q, 0);
    invariant success ==> Inv(v);
  {
//    sentinel := [q];
    open_region
      using Qu(q_r, q_lvl, q);
    {
      sl := q.sentinel;
      // ghost: Duplicate sentinel's region assertion
      assert q_r._sentinel_id |-> ?sl_r0;
      assert q_r._sentinel_level |-> ?sl_lvl0;
      assert QL(sl_r0, sl_lvl0, sl, ?sl_a0);
      inhale QL(sl_r0, sl_lvl0, sl);
      assert sl_a0 >= 0; // [DEBUG]
      assert sl_a0 mod 3 == 1; // [DEBUG]
    }

//    head := [sentinel + 1];
    open_region
      using QL(sl_r0, sl_lvl0, sl);
    {
      hd := sl.next;
      // ghost: If head present, duplicate its region assertion
      if (hd != null) {
        assert sl_r0._next_id |-> ?hd_r0;
        assert sl_r0._next_level |-> ?hd_lvl0;
        assert QL(hd_r0, hd_lvl0, hd, ?hd_a0);
        inhale QL(hd_r0, hd_lvl0, hd);
      }
    }

    if (hd == null) {
//      return 0;
      done := true;
      success := false;
    } else {
//      r := CAS(q, sentinel, hd);
      acquire_guard G@q_r;
      use_atomic
        using Qu(q_r, q_lvl, q) with G@q_r;
      {
        // Bind various logical variables
        assert q_r._sentinel_id |-> ?sl_r1;
        assert q_r._sentinel_level |-> ?sl_lvl1;
        assert q.sentinel |-> ?sl1; // Note: Reading a non-ghost-field this way might look fishy, but it
                                    // "merely" compensates for Voila's limited support for existentials
        assert QL(sl_r1, sl_lvl1, sl1, ?sl_a1);

        
          success := CAS_sentinel(q, sl, hd);
          // If dequeue succeeded, perform various ghost operations
          if (success) {
            // Since the CAS succeeded, q.sentinel was sl before the CAS.
            assert sl1 == sl; // [DEBUG]
            assume sl_r1 == sl_r0 && sl_lvl1 == sl_lvl0; // TODO: Implied by sl1 == sl, see also issue #16
            assert sl_a1 >= 0; // [DEBUG]
            assert sl_a1 mod 3 == 1; // [DEBUG]

            q_r._sentinel_id := hd_r0;
            q_r._sentinel_level := hd_lvl0;

            use_atomic
              using QL(sl_r1, sl_lvl0, sl) with OWN@sl_r1;
            {
              assert sl.next |-> ?hd1;
              if (hd1 != hd) {
                assume false;
                  // TODO: False provable in Caper (i.e. code unreachable), but not in Voila.
                  //
                  // My current understanding is the following: without knowing that sentinel
                  // still precedes head we won't get OWN for head out of the sentinel (we would
                  // get it for some other node), which in turn would prevent us from changing
                  // the abstract state of the head region, which we need in order to take the
                  // invariant out of the region.
                  //
                  // I believe that Caper can prove that the sentinel's successor cannot have
                  // changed in the meantime because the action used there effectively disallow
                  // changing the next pointer once it is non-null.
              }

              assert sl_r1._next_id |-> ?hd_r1 && sl_r1._next_level |-> ?hd_lvl1;
              assume hd_r1 == hd_r0 && hd_lvl1 == hd_lvl0; // TODO: Implied by hd1 == hd, see Voila issue #16

              assert sl_a1 mod 3 == 1; // [DEBUG]
              assert sl_a1 >= 4; // [DEBUG]
              sl_r1._absstate := sl_a1 + 1; // Update abstract state of QL(sl_r1, ...)
              assert (sl_a1 + 1) >= 5; // [DEBUG]
              assert (sl_a1 + 1) mod 3 == 2; // [DEBUG]

              use_atomic
                using QL(hd_r0, hd_lvl0, hd) with OWN@hd_r0;
              {
                assert hd_r0._absstate |-> ?u40;
                assert hd.value |-> ?v0; // [DEBUG]
                assert u40 mod 3 == 0; // [DEBUG]
                assert u40 == 0 || u40 >= 3; // [DEBUG]
                assert Inv(v0); // [DEBUG]
                assume u40 == 0; // TODO: Get rid of (case split?). Could also be a non-issue once overlapping actions are supported.
                hd_r0._absstate := u40 + 1; // Update abstract state of QL(hd_r0, ...)
              }

              // Duplicate region assertion
              assert QL(hd_r0, hd_lvl0, hd);
              inhale QL(hd_r0, hd_lvl0, hd);
            }
          }
        
      }

//        if (r != 0)
      if (success) {
//          res := [head];
//          return res;
        open_region
          using QL(hd_r0, hd_lvl0, hd);
        {
          v := hd.value;
          // assume v == v0; // TODO: Not necessary if v were an in-argument, see comment at decl. of region QL
        }
      }
    }
  }
}



primitive_atomic procedure CAS_next(node x, node now, node thn) returns (bool ret)
  requires x.next |-> ?v;
  ensures  v == now
              ? ret && x.next |-> thn
              : !ret && x.next |-> v;

primitive_atomic procedure CAS_sentinel(queue x, node now, node thn) returns (bool ret)
  requires x.sentinel |-> ?v;
  ensures  v == now
              ? ret && x.sentinel |-> thn
              : !ret && x.sentinel |-> v;

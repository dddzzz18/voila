// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/SpinLock.t
//

struct memcell {
  int f;
}

region SLock(id r, int lvl, memcell x)
  guards {
    duplicable LOCK;
    unique UNLOCK;
  }
  interpretation {
    x.f |-> ?v &&
    (v == 0 ? UNLOCK@r :
     v == 1 ? true :
     false)
  }
  state { v }
  actions {
    LOCK:   0 ~> 1;
    UNLOCK: 1 ~> 0;
  }

// TODO: Too many issues
procedure makeLock(id r, int lvl) returns (memcell ret)
//  // ensures SLock(r, lvl, ret, 0) && LOCK@r; // TODO: See issue #23
{
//  // ret := alloc(1); // See Voila issue #17
//  memcell x;
//  havoc x;
//  inhale (x.f |-> ?v);
//  x.f := 0;
//
//  inhale UNLOCK@r; // See Voila issues #18 ...
//  inhale LOCK@r;   // ... and #19
//  fold SLock(r, lvl, x, 0);
//
//  ret := x;
}

abstract_atomic procedure acquire(id r, int lvl, memcell x)
  interference ?v in Set(0, 1) on r;
  requires SLock(r, lvl, x) && LOCK@r;
  ensures  SLock(r, lvl, x, 1);
  ensures  UNLOCK@r;
  ensures  LOCK@r;
{
  bool b;

  make_atomic
    using SLock(r, lvl, x) with LOCK@r;
  {
    do
      invariant SLock(r, lvl, x);
      invariant !b ==> r |=> <D>; // TODO: Why isn't it necessary to specify LOCK@r here?
      invariant  b ==> r |=> (0, 1) && UNLOCK@r;
    {
      update_region
        using SLock(r, lvl, x);
      {
        b := CAS(x, 0, 1);
      }
    } while (!b);
  }
}

abstract_atomic procedure release1(id r, int lvl, memcell x)
  interference ?s in Set(1) on r;
  requires SLock(r, lvl, x, 1) && UNLOCK@r;
  ensures  SLock(r, lvl, x, 0) && LOCK@r;
{
  /* PROBLEM: Rule make-atomic temporarily consumes the used guard, which thus
   *          isn't available in the body. There, folding SLock(r, lvl, x, 0) fails.
   *
   *          This seems to be a limitation of/design decision made by TaDA.
   */
  make_atomic
    using SLock(r, lvl, x) with UNLOCK@r;
  {
    //:: ExpectedOutput(update-region_error:guard_permission_error)
    update_region
      using SLock(r, lvl, x);
    {
      x.f := 0;
    }
  }
}

abstract_atomic procedure release2(id r, int lvl, memcell x)
  interference ?s in Set(1) on r;
  requires SLock(r, lvl, x, 1) && UNLOCK@r;
  ensures  SLock(r, lvl, x, 0);
  //:: UnexpectedOutput(postcondition_error:guard_permission_error, /voila/issue/19/)
  ensures  LOCK@r;
{
  use_atomic
    using SLock(r, lvl, x) with UNLOCK@r;
  {
    x.f := 0;
  }
}


primitive_atomic procedure CAS(memcell x, int now, int thn) returns (bool ret)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

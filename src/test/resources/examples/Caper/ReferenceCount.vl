// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/ReferenceCount.t
//

predicate object()

procedure create()
  requires true;
  ensures  object();

procedure destroy()
  requires object();
  ensures  true;


// ----- Atomic reference count region -----

struct arcell {
  int value;
}

region ARCounter(id r, int lvl, arcell c)
  ghost_fields { int _absstate; }
  guards {
    duplicable ARC(int n);
    duplicable Z;
  }
  interpretation {
//    n > 0 | n : object() &*& r@arc|-1-n| &*& c |-> n;
//    0 : r@arc|-1|;
    r._absstate |-> ?n && 0 <= n &&
    (n > 0 ? object() && ARC(-1-n)@r && c.value |-> n : ARC(-1)@r)
    // TODO: Ghost field _absstate wouldn't be needed if c.value |-> were always in the region.
    //       Removing _absstate would reduce the amount of ghost.
  }
  state { n }
  actions {
//    n > 0, m >= 0 | : n ~> m;
    ?n, ?m | 0 < n && 0 <= m | Z: n ~> m;
  }

// Encoding of counting guard algebra ARC

// From the Caper paper (p. 14):
//   GUARD|n| ∗ GUARD|m| = GUARD|n + m|
//   if (n ≥ 0 ∧ m ≥ 0) ∨ (n < 0 ∧ m ≥ 0 ∧ n + m < 0) ∨ (n ≥ 0 ∧ m < 0 ∧ n + m < 0)

macro counting_algebra_constraints(n, m)
  (0 <= n && 0 <= m) ||
  (n < 0 && 0 <= m && n + m < 0) ||
  (m < 0 && 0 <= n && n + m < 0);

/* lemma */ procedure ARC_split(id r, int n, int m)
  requires ARC(n + m)@r;
  requires counting_algebra_constraints(n, m);
  ensures  ARC(n)@r && ARC(m)@r;

/* lemma */ procedure ARC_join(id r, int n, int m)
  requires ARC(n)@r && ARC(m)@r;
  requires counting_algebra_constraints(n, m);
  ensures  ARC(n + m)@r;

/* lemma */ procedure ARC_false1(id r, int n) // TODO: Provable from ARC_split and Arc_join?
  requires ARC(-1)@r && ARC(n)@r && 0 < n;
  ensures  false;


// ----- Functionality -----

procedure init(int lvl) returns (id r, arcell c)
  requires lvl >= 0;
  ensures  ARCounter(r, lvl, c) && ARC(1)@r;
{
  create();

  // c := alloc(1);
  // [c] := 1
  c := new arcell(1);

  // Create region ARCounter(r, lvl, c)
  r := new ARCounter(lvl, c) with ARC(-1) {
    r._absstate := 0;
  }

  // Manipulate abstract state and guard to establish postcondition (TODO: view shift?)
  unfold ARCounter(r, lvl, c);
  r._absstate := 1;
  use ARC_split(r, -2, 1);
  fold ARCounter(r, lvl, c);
}

//macro prune_infeasible_proof_branch(r, c) {
//  assert r._absstate |-> ?a;
//  assert 0 <= a;
//  if (a == 0) {
//    use ARC_false1(r, 1);
//    assert false;
//  }
//}
//
//procedure clone(id r, int lvl, arcell c)
//  requires ARCounter(r, lvl, c) && ARC(1)@r;
//  requires Z@r;
//  ensures  ARCounter(r, lvl, c) && ARC(2)@r;
//{
//  int cnt;
//  bool b;
//
//  do
//    invariant !b ? ARCounter(r, lvl, c) && ARC(1)@r && Z@r : ARCounter(r, lvl, c) && ARC(2)@r;
//  {
//    // cnt := [c];
//    open_region
//      using ARCounter(r, lvl, c);
//    {
//      prune_infeasible_proof_branch(r, c); // ghost
//
//      cnt := c.value;
//    }
//
//    // b := CAS(c,cnt,cnt+1);
//    use_atomic
//      using ARCounter(r, lvl, c) with Z@r;
//    {
//      prune_infeasible_proof_branch(r, c); // ghost
//
//      b := CAS(c, cnt, cnt + 1);
//
//      // ghost
//      if (b) {
//        exhale r._absstate |-> cnt;
//        inhale r._absstate |-> cnt + 1;
//        use ARC_split(r, -1-(cnt+1), 1); // split-off another ARC(1)
//        use ARC_join(r, 1, 1); // join two ARC(1) into one ARC(2)
//      }
//    }
//  } while (!b);
//}
//
//procedure drop(id r, int lvl, arcell c)
//  requires ARCounter(r, lvl, c) && ARC(1)@r;
//  requires Z@r;
//  ensures  true;
//{
//  int cnt;
//  bool b;
//
//  do
//    invariant !b ? ARCounter(r, lvl, c) && ARC(1)@r && Z@r : (cnt == 1 ==> object());
//  {
//    open_region
//      using ARCounter(r, lvl, c);
//    {
//      prune_infeasible_proof_branch(r, c); // ghost
//
//      cnt := c.value;
//    }
//
//    use_atomic
//      using ARCounter(r, lvl, c) with Z@r;
//    {
//      prune_infeasible_proof_branch(r, c); // ghost
//
//      b := CAS(c, cnt, cnt - 1);
//
//      // ghost
//      if (b) {
//        exhale r._absstate |-> cnt;
//        inhale r._absstate |-> cnt - 1;
//        use ARC_join(r, -1-cnt, 1); // join back ARC(1)
//      }
//    }
//
//  } while (!b);
//
//  if (cnt == 1) {
//    destroy();
//  }
//}

primitive_atomic procedure CAS(arcell x, int now, int thn) returns (bool ret)
  requires x.value |-> ?v;
  ensures  v == now
              ?  ret && x.value |-> thn
              : !ret && x.value |-> v;

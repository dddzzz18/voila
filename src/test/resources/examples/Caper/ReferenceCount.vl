// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/ReferenceCount.t
//

predicate object()

procedure create()
  requires true;
  ensures  object();

procedure destroy()
  requires object();
  ensures  true;


// Atomic reference count region

struct arcell {
  int value;
  int _absstate; // ghost
}

region ARCounter(id r, arcell c)
  guards {
    duplicable ARC(int n);
    duplicable Z;
  }
  interpretation {
//    n > 0 | n : object() &*& r@arc|-1-n| &*& c |-> n;
//    0 : r@arc|-1|;
    c._absstate |-> ?n && 0 <= n &&
    (n > 0 ? object() && ARC(-1-n)@r && c.value |-> n : ARC(-1)@r)
    // TODO: Ghost field _absstate wouldn't be needed if c.value |-> were always in the region.
    //       Removing _absstate would reduce the amount of ghost.
  }
  state { n }
  actions {
//    n > 0, m >= 0 | : n ~> m;
    ?n, ?m | 0 < n && 0 <= m | Z: n ~> m;
  }

// From the Caper paper (p. 14):
//   GUARD|n| ∗ GUARD|m| = GUARD|n + m|
//   if (n ≥ 0 ∧ m ≥ 0) ∨ (n < 0 ∧ m ≥ 0 ∧ n + m < 0) ∨ (n ≥ 0 ∧ m < 0 ∧ n + m < 0)

macro ARC_split_join_pre(n, m)
  (0 <= n && 0 <= m) ||
  (n < 0 && 0 <= m && n + m < 0) ||
  (m < 0 && 0 <= n && n + m < 0);

/* lemma */ procedure ARC_split(id r, int n, int m)
  requires ARC(n + m)@r;
  requires ARC_split_join_pre(n, m);
  ensures  ARC(n)@r && ARC(m)@r;

/* lemma */ procedure ARC_join(id r, int n, int m)
  requires ARC(n)@r && ARC(m)@r;
  requires ARC_split_join_pre(n, m);
  ensures  ARC(n + m)@r;

/* lemma */ procedure ARC_false1(id r, int n) // TODO: Provable from ARC_split and Arc_join?
  requires ARC(-1)@r && ARC(n)@r && 0 < n;
  ensures  false;

procedure init() returns (id r, arcell c)
  requires true;
  ensures  ARCounter(r, c) && ARC(1)@r;
{
  create();

  // c := alloc(1);
  inhale c.value |-> _;

  c.value := 1;

  // Create region ARCounter(r, c)
  inhale ARC(-1)@r;
  inhale c._absstate |-> 0;
  fold ARCounter(r, c);

  // Manipulate abstract state and guard to establish postcondition (TODO: view shift?)
  unfold ARCounter(r, c);
  exhale c._absstate |-> _;
  inhale c._absstate |-> 1;
  use ARC_split(r, -2, 1);
  fold ARCounter(r, c);
}

macro prune_infeasible_proof_branch(r, c) {
  assert c._absstate |-> ?a;
  assert 0 <= a;
  if (a == 0) {
    use ARC_false1(r, 1);
    assert false;
  }
}

procedure clone(id r, arcell c)
  requires ARCounter(r, c) && ARC(1)@r;
  requires Z@r;
  ensures  ARCounter(r, c) && ARC(2)@r;
{
  int cnt;
  bool b;

  do
    invariant !b ? ARCounter(r, c) && ARC(1)@r && Z@r : ARCounter(r, c) && ARC(2)@r;
  {
    // cnt := [c];
    open_region
      using ARCounter(r, c);
    {
      prune_infeasible_proof_branch(r, c); // ghost

      cnt := c.value;
    }

    // b := CAS(c,cnt,cnt+1);
    use_atomic
      using ARCounter(r, c) with Z@r;
    {
      prune_infeasible_proof_branch(r, c); // ghost

      b := CAS(c, cnt, cnt + 1);

      // ghost
      if (b) {
        exhale c._absstate |-> cnt;
        inhale c._absstate |-> cnt + 1;
        use ARC_split(r, -1-(cnt+1), 1); // split-off another ARC(1)
        use ARC_join(r, 1, 1); // join two ARC(1) into one ARC(2)
      }
    }
  } while (!b);
}

procedure drop(id r, arcell c)
  requires ARCounter(r, c) && ARC(1)@r;
  requires Z@r;
  ensures  true;
{
  int cnt;
  bool b;

  do
    invariant !b ? ARCounter(r, c) && ARC(1)@r && Z@r : (cnt == 1 ==> object());
  {
    open_region
      using ARCounter(r, c);
    {
      prune_infeasible_proof_branch(r, c); // ghost

      cnt := c.value;
    }

    use_atomic
      using ARCounter(r, c) with Z@r;
    {
      prune_infeasible_proof_branch(r, c); // ghost

      b := CAS(c, cnt, cnt - 1);

      // ghost
      if (b) {
        exhale c._absstate |-> cnt;
        inhale c._absstate |-> cnt - 1;
        use ARC_join(r, -1-cnt, 1); // join back ARC(1)
      }
    }

  } while (!b);

  if (cnt == 1) {
    destroy();
  }
}

primitive_atomic procedure CAS(arcell x, int now, int thn) returns (bool ret)
  requires x.value |-> ?v;
  ensures  v == now
              ?  ret && x.value |-> thn
              : !ret && x.value |-> v;

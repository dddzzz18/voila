//:: IgnoreFile(/voila/issue/49/)

region RWLock(id r, int lvl, memcell x)
  guards {
    duplicable WLOCK;
    unique WUNLOCK;
    unique RLOCK1;
    unique RUNLOCK1;
    unique RLOCK2;
    unique RUNLOCK2;
  }
  interpretation {
    x.f |-> ?v &&
    (v ==  0 ? RUNLOCK1@r && RUNLOCK2@r && WUNLOCK@r :
     v ==  1 ? WUNLOCK@r && RUNLOCK2@r :
     v ==  2 ? WUNLOCK@r && RUNLOCK1@r :
     v ==  3 ? WUNLOCK@r :
     v == -1 ? RUNLOCK1@r && RUNLOCK2@r :
     false)
  }
  state { v }
  actions {
    RLOCK1  :  0 ~>  1;
    RUNLOCK1:  1 ~>  0;
    RLOCK2  :  0 ~>  2;
    RUNLOCK2:  2 ~>  0;
    RLOCK1  :  2 ~>  3;
    RUNLOCK1:  3 ~>  2;
    RLOCK2  :  1 ~>  3;
    RUNLOCK2:  3 ~>  1;
    WLOCK   :  0 ~> -1;
    WUNLOCK : -1 ~>  0;
  }



abstract_atomic procedure readerAcquire1AA(id r, int lvl, memcell x)
  interference ?m in Set(-1, 0, 2) on r;
  requires RWLock(r, lvl, x, m) && RLOCK1@r;
  ensures  RWLock(r, lvl, x, ?n) && RLOCK1@r && RUNLOCK1@r;
  ensures  m in Set(0, 2) && n == m + 1;
{
  int v;
  bool b;

  make_atomic
    using RWLock(r, lvl, x) with RLOCK1@r;
  {
    do
      invariant RWLock(r, lvl, x);
      invariant !b ==> r |=> <D> ;
      invariant  b ==> r |=> (v, v + 1) && (v in Set(0, 2)) && RUNLOCK1@r;
    {
      open_region
        using RWLock(r, lvl, x);
      {
        v := x.f;
      }

      if (v >= 0) {
        update_region
          using RWLock(r, lvl, x);
        {
          b := CAS(x, v, v + 1);
        }
      } else {
        b := false;
      }
    } while (!b);
  }
}

procedure readerAcquire1a(id r, int lvl, memcell x)
  requires RWLock(r, lvl, x, ?m) && RLOCK1@r && m != 1 && m != 3;
  ensures  RWLock(r, lvl, x, ?n) && RLOCK1@r && RUNLOCK1@r && n > 0;
{
  use_region_interpretation RWLock(r, lvl, x);
    // Learn that m != 1 && m != 3 implies that m in {-1, 0, 2}
  readerAcquire1AA(r, lvl,x);
}

procedure readerAcquire1b(id r, int lvl, memcell x)
  requires RWLock(r, lvl, x, ?m) && RLOCK1@r && m in Set(-1, 0, 2);
  ensures  RWLock(r, lvl, x, ?n) && RLOCK1@r && RUNLOCK1@r && n > 0;
{
  readerAcquire1AA(r, lvl,x);
}



abstract_atomic procedure readerRelease2AA(id r, int lvl, memcell x)
  interference ?m in Set(2, 3) on r;
  requires RWLock(r, lvl, x, m) && RUNLOCK2@r;
  ensures  RWLock(r, lvl, x);
{
  int v;
  bool b;

  make_atomic
    using RWLock(r, lvl, x) with RUNLOCK2@r;
  {
    do
      invariant RWLock(r, lvl, x);
      invariant !b ==> r |=> <D>;
      invariant  b ==> r |=> (v, v - 2) && (v in Set(2, 3));
    {
      open_region
        using RWLock(r, lvl, x);
      {
        v := x.f;
      }

      //:: ExpectedOutput(update-region_error:guard_permission_error)
      //      Cannot close region RWLock(r, lvl, x) after a successful update: guard
      //      RUNLOCK2@r, which must go into the region, is currently not
      //      available since it is used by the surrounding make-atomic rule.
      update_region
        using RWLock(r, lvl, x);
      {
        b := CAS(x, v, v - 2);
      }
    } while (!b);
  }
}



abstract_atomic procedure writerAcquireAA(id r, int lvl, memcell x)
  interference ?m in Int on r;
  requires RWLock(r, lvl, x, m) && WLOCK@r;
  ensures  RWLock(r, lvl, x, -1) && WLOCK@r && WUNLOCK@r;
{
  bool b;

  make_atomic
    using RWLock(r, lvl, x) with WLOCK@r;
  {
    do
      invariant RWLock(r, lvl, x);
      invariant !b ==> r |=> <D>;
      invariant  b ==> r |=> (0, -1) && WUNLOCK@r;
    {
      update_region
        using RWLock(r, lvl, x);
      {
        b := CAS(x, 0, -1);
      }
    } while (!b);
  }
}

abstract_atomic procedure writerReleaseAA(id r, int lvl, memcell x)
  interference ?m in Set(-1) on r;
  requires RWLock(r, lvl, x, m) && WUNLOCK@r;
  ensures  RWLock(r, lvl, x);
{
  use_atomic
    using RWLock(r, lvl, x) with WUNLOCK@r;
  {
    x.f := 0;
  }
}

abstract_atomic procedure writerRelease(id r, int lvl, memcell x)
  requires RWLock(r, lvl, x, -1) && WUNLOCK@r;
  ensures  RWLock(r, lvl, x);
{
  writerReleaseAA(r, lvl, x);
}



primitive_atomic procedure CAS(memcell x, int now, int thn) returns (bool ret)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

struct memcell {
  int f;
}

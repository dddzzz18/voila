// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/CASCounter.t
//

struct memcell {
  int f;
}

region Counter(id r, memcell x)
  guards { duplicable INCREMENT; }
  interpretation { x.f |-> ?v }
  state { v }
  actions {
    ?n, ?m | n < m | INCREMENT: n ~> m;
  }

// TODO: makeCounter()

procedure incr(id r, memcell x) returns (int ret)
  requires Counter(r, x, ?v0) && INCREMENT@r;
  ensures  Counter(r, x, ?v1) && INCREMENT@r;
  ensures  v0 < v1;
{
  int v;
  bool b;

  do
    invariant Counter(r, x, ?vi) && INCREMENT@r;
    invariant b ? v0 < vi : v0 <= vi;
  {
    open_region
      using Counter(r, x);
    {
      v := x.f;
    }
    use_atomic
      using Counter(r, x) with INCREMENT@r;
    {
      b := CAS(x, v, v + 1);
    }
  } while (!b);
}

procedure read(id r, memcell x) returns (int ret)
  requires Counter(r, x, ?v0) && INCREMENT@r;
  ensures  Counter(r, x, ?v1) && INCREMENT@r;
  ensures  ret <= v1;
{
  open_region
    using Counter(r, x);
  {
    ret := x.f;
  }
}

primitive_atomic procedure CAS(memcell x, int now, int thn) returns (bool ret)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

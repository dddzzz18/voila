// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/BoundedCounter.t
//

region BCounter(id r, memcell x)
  guards { duplicable INCREMENT; }
  interpretation {
    x.f |-> ?v &&
    (v == 0 || v == 1 || v == 2)
  }
  state { v }
  actions {
    // TODO: Are these action definitions transitively closed?
    INCREMENT: ?n if n < 2 ~> Set(?m | n <= m <= 2);
    INCREMENT: 2 ~> Set(2, 0);
  }

// TODO: implement makeCounter()
//function makeCounter()
//  requires true;
//  ensures BCounter(r, ret,0) &*& r@INCREMENT[1p];
//{
//    v := alloc(1);
//    [v] := 0;
//    return v;
//}

// Note: The Caper encoding can provide stronger guarantees in the case where
//       the environment cannot change the counter, which (in Caper) is known
//       if the current invocation of incr has full permissions to the
//       INCREMENT guard. I am not sure if something similar is possible in TaDA;
//       it is not supported by Voila in any case.
int incr(id r, memcell x)
  requires BCounter(r, x, ?v0) && INCREMENT@r;
  ensures  BCounter(r, x, ?v1) && INCREMENT@r;
  ensures  0 <= ret <= 2;
{
  int v;
  int w;
  bool b;

  do
    invariant BCounter(r, x);
    invariant 0 <= v <= 2;
  {
    open_region
      using BCounter(r, x);
    {
      v := x.f;
    }

    if (v < 2) {
      w := v + 1;
    } else {
      w := 0;
    }

    use_atomic
      using BCounter(r, x) with INCREMENT@r;
    {
      b := CAS(x, v, w);
    }
  } while (!b);

  ret := v;
}

int read(id r, memcell x)
  requires BCounter(r, x, ?v0) && INCREMENT@r;
  ensures  BCounter(r, x, ?v1) && INCREMENT@r;
  ensures  ret == 0 || ret == 1 || ret == 2;
{
  open_region
    using BCounter(r, x);
  {
    ret := x.f;
  }
}

primitive_atomic bool CAS(memcell x, int now, int thn)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

struct memcell {
  int f;
}

// Corresponds to:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/BoundedCounter.t
//

region RWLock(id r, memcell x)
  guards {
    duplicable WLOCK;
    unique WUNLOCK;
    unique RLOCK1;
    unique RUNLOCK1;
    unique RLOCK2;
    unique RUNLOCK2;
  }

  interpretation {
    x.f |-> ?v &&
    (v ==  0 ? RUNLOCK1@r && RUNLOCK2@r && WUNLOCK@r :
     v ==  1 ? WUNLOCK@r && RUNLOCK2@r :
     v ==  2 ? WUNLOCK@r && RUNLOCK1@r :
     v ==  3 ? WUNLOCK@r :
     v == -1 ? RUNLOCK1@r && RUNLOCK2@r :
     false)
  }
  state { v }
  actions {
    RLOCK1   :  0 ~> Set(0, 1);
    RUNLOCK1 :  1 ~> Set(1, 0);
    RLOCK2   :  0 ~> Set(0, 2);
    RUNLOCK2 :  2 ~> Set(2, 0);
    RLOCK1   :  2 ~> Set(2, 3);
    RUNLOCK1 :  3 ~> Set(3, 2);
    RLOCK2   :  1 ~> Set(1, 3);
    RUNLOCK2 :  3 ~> Set(3, 1);
    WLOCK    :  0 ~> Set(0, -1);
    WUNLOCK  : -1 ~> Set(-1, 0);
  }


// TODO: encode makeLock()
// function makeLock()
//   requires true;
//   ensures RWLock(r, ret, 0) &*& r@(RLOCK1 * RLOCK2 * WLOCK[1p]);
// {
//     v := alloc(1);
//     [v] := 0;
//     return v;
// }


void readerAcquire1(id r, memcell x)
  requires RWLock(r, x, ?m) && RLOCK1@r && m != 1 && m != 3;
  ensures  RWLock(r, x, ?n) && RLOCK1@r && RUNLOCK1@r && n > 0;
{
  int v;
  bool b;

  // RWLock state in {-1, 0, 2}

  do
    invariant RWLock(r, x, ?mi) && RLOCK1@r;
    invariant !b ? mi != 1 && mi != 3 : mi > 0 && RUNLOCK1@r;
  {
    use_atomic
      using RWLock(r, x) with RLOCK1@r;
    {
      v := x.f;
      // RWLock state in {-1, 0, 2}
      // Thus,      v in {-1, 0, 2}
    }

    if (v >= 0) {
      use_atomic
        using RWLock(r, x) with RLOCK1@r;
      {
        // Attempt physical state change 0/2 ~> 1/3
        b := CAS(x, v, v + 1);
      }
    } else {
      b := false;
    }
  } while (!b);

  use_region_interpretation RWLock(r, x);
    // Learn that holding RUNLOCK1@r implies that RWLock's state is greater 0
}

void readerRelease1(id r, memcell x)
  requires RWLock(r, x, ?n) && n > 0 && RUNLOCK1@r;
  ensures  RWLock(r, x);
{
  int v;
  bool b;

  do
    invariant RWLock(r, x, ?ni);
    invariant !b ==> ni > 0 && RUNLOCK1@r;
  {
    use_region_interpretation RWLock(r, x);
      // Learn that holding RUNLOCK1@r implies that RWLock's state is in {1, 3}

    open_region
      using RWLock(r, x);
    {
      v := x.f;
    }

    use_atomic
      using RWLock(r, x) with RUNLOCK1@r;
    {
      // Attempt physical state change 1/3 ~> 0/2
      b := CAS(x, v, v - 1);
    }
  } while (!b);
}

void readerAcquire2(id r, memcell x)
  requires RWLock(r, x, ?m) && RLOCK2@r && m != 2 && m != 3;
  ensures  RWLock(r, x, ?n) && RLOCK2@r && RUNLOCK2@r && n > 0;
{
  int v;
  bool b;

  // RWLock state in {-1, 0, 1}

  do
    invariant RWLock(r, x, ?mi) && RLOCK2@r;
    invariant !b ? mi != 2 && mi != 3 : mi > 0 && RUNLOCK2@r;
  {
    use_atomic
      using RWLock(r, x) with RLOCK2@r;
    {
      v := x.f;
      // RWLock state in {-1, 0, 1}
      // Thus,      v in {-1, 0, 1}
    }

    if (v >= 0) {
      use_atomic
        using RWLock(r, x) with RLOCK2@r;
      {
        // Attempt physical state change 0/1 ~> 2/3
        // Not symmetric w.r.t. to readerAcquire1 (unlike in Caper)
        b := CAS(x, v, v + 2);
      }
    } else {
      b := false;
    }
  } while (!b);

  use_region_interpretation RWLock(r, x);
    // Learn that holding RUNLOCK2@r implies that RWLock's state is greater 0
}

void readerRelease2(id r, memcell x)
  requires RWLock(r, x, ?n) && n > 0 && RUNLOCK2@r;
  ensures  RWLock(r, x);
{
  int v;
  bool b;

  do
    invariant RWLock(r, x, ?ni);
    invariant !b ==> ni > 0 && RUNLOCK2@r;
  {
    use_region_interpretation RWLock(r, x);
      // Learn that holding RUNLOCK2@r implies that RWLock's state is in {2, 3}

    open_region
      using RWLock(r, x);
    {
      v := x.f;
    }

    use_atomic
      using RWLock(r, x) with RUNLOCK2@r;
    {
      b := CAS(x, v, v - 2);
        // Attempt physical state change 2/3 ~> 0/1
        // Not symmetric w.r.t. to readerAcquire1 (unlike in Caper)
    }
  } while (!b);
}

void writerAcquire(id r, memcell x)
  requires RWLock(r, x) && WLOCK@r;
  ensures  RWLock(r, x, -1) && WLOCK@r && WUNLOCK@r;
{
  bool b;

  do
    invariant WLOCK@r;
    invariant !b ? RWLock(r, x) : RWLock(r, x, -1) && WUNLOCK@r;
  {
    use_atomic
      using RWLock(r, x) with WLOCK@r;
    {
      b := CAS(x, 0, -1);
    }
  } while (!b);
}

void writerRelease(id r, memcell x)
  requires RWLock(r, x, -1) && WUNLOCK@r;
  ensures  RWLock(r, x);
{
  use_atomic
    using RWLock(r, x) with WUNLOCK@r;
  {
    x.f := 0;
  }
}



primitive_atomic bool CAS(memcell x, int now, int thn)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

struct memcell {
  int f;
}

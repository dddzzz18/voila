//:: IgnoreFile(/voila/issue/49/)

region Cell(id s, int lvl, memcell x)
  guards { unique G; }
  interpretation { x.f |-> ?v }
  state { v }
  actions {
    G: ?n ~> ?m;
  }

abstract_atomic procedure spinCAS(id s, int lvl,
                                  memcell x,
                                  set<int> from)
                                  // lambda<bool(int)> cas_if,
                                  // lambda<int(int)> cas_to)
  interference ?m in from on s;
  requires Cell(s, lvl, x, m) && G@s;
  // requires forall v: Int :: v != cas_to(v) // Voila issue #8
  ensures  Cell(s, lvl, x, ?n) && G@s;
  // ensures  cas_if(m);
  // ensures  n == cas_to(m);
{
  int v;
  bool b;

  bool cas_if;
  int cas_to;

  make_atomic
    using Cell(s, lvl, x) with G@s;
  {
    do
      invariant Cell(s, lvl, x);
      invariant !b ==> s |=> <D>;
//      invariant  b ==> s |=> (v, cas_to(v)) && (v in from) && cas_if(v);
      invariant  b ==> s |=> (v, cas_to) && (v in from) && cas_if;
    {
      open_region
        using Cell(s, lvl, x);
      {
        v := x.f;
      }

      havoc cas_if;
      havoc cas_to;
      assume cas_to != v; // Voila issue #8

//      if (cas_if(v)) {
      if (cas_if) {
        update_region
          using Cell(s, lvl, x);
        {
//          b := CAS(x, v, cas_to(v));
          b := CAS(x, v, cas_to);
        }
      } else {
        b := false;
      }
    } while (!b);
  }
}

//
// From Caper/BoundedReadWriteLock
//

region RWLock(id r, int alvl, id s, int lvl, memcell x)
  guards {
    duplicable WLOCK;
    unique WUNLOCK;
    unique RLOCK1;
    unique RUNLOCK1;
    unique RLOCK2;
    unique RUNLOCK2;
  }
  interpretation {
    Cell(s, lvl, x, ?v) && lvl < alvl && G@s &&
    (v ==  0 ? RUNLOCK1@r && RUNLOCK2@r && WUNLOCK@r :
     v ==  1 ? WUNLOCK@r && RUNLOCK2@r :
     v ==  2 ? WUNLOCK@r && RUNLOCK1@r :
     v ==  3 ? WUNLOCK@r :
     v == -1 ? RUNLOCK1@r && RUNLOCK2@r :
     false)
  }
  state { v }
  actions {
    RLOCK1  :  0 ~>  1;
    RUNLOCK1:  1 ~>  0;
    RLOCK2  :  0 ~>  2;
    RUNLOCK2:  2 ~>  0;
    RLOCK1  :  2 ~>  3;
    RUNLOCK1:  3 ~>  2;
    RLOCK2  :  1 ~>  3;
    RUNLOCK2:  3 ~>  1;
    WLOCK   :  0 ~> -1;
    WUNLOCK : -1 ~>  0;
  }

procedure readerAcquire1(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl, s, lvl, x, ?m) && RLOCK1@r && m != 1 && m != 3;
  ensures  RWLock(r, alvl, s, lvl, x, ?n) && RLOCK1@r && RUNLOCK1@r && n > 0;
{
  use_region_interpretation RWLock(r, alvl, s, lvl, x);
    // Learn that m != 1 && m != 3 implies that m in {-1, 0, 2}

  use_atomic
    using RWLock(r, alvl, s, lvl, x) with RLOCK1@r;
  {
    assert Cell(s, lvl, x, ?v); // Bind region value before call
    spinCAS(s, lvl, x, Set(-1, 0, 2));
      // cas_if := \v -> v >= 0
      // cas_to := \v -> v + 1
    assert Cell(s, lvl, x, ?w); // Bind region value after call
    assume v >= 0; // From cas_if
    assume w == v + 1; // From cas_to
  }
}

procedure readerRelease1(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl, s, lvl, x, ?n) && n > 0 && RUNLOCK1@r;
  ensures  RWLock(r, alvl, s, lvl, x);
{
  use_region_interpretation RWLock(r, alvl, s, lvl, x);
    // Learn that n > 0 && RUNLOCK1@r implies that n in {1, 3}

  use_atomic
    using RWLock(r, alvl, s, lvl, x) with RUNLOCK1@r;
  {
    assert Cell(s, lvl, x, ?v); // Bind region value before call
    spinCAS(s, lvl, x, Set(1, 3));
      // cas_if := \v -> true
      // cas_to := \v -> v - 1
    assert Cell(s, lvl, x, ?w); // Bind region value after call
    assume true; // From cas_if
    assume w == v - 1; // From cas_to
  }
}

procedure readerAcquire2(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl, s, lvl, x, ?m) && RLOCK2@r && m != 2 && m != 3;
  ensures  RWLock(r, alvl, s, lvl, x, ?n) && RLOCK2@r && RUNLOCK2@r && n > 0;
{
  use_region_interpretation RWLock(r, alvl, s, lvl, x);
    // Learn that m != 1 && m != 3 implies that m in {-1, 0, 1}

  use_atomic
    using RWLock(r, alvl, s, lvl, x) with RLOCK2@r;
  {
    assert Cell(s, lvl, x, ?v); // Bind region value before call
    spinCAS(s, lvl, x, Set(-1, 0, 1));
      // cas_if := \v -> v >= 0
      // cas_to := \v -> v + 2
    assert Cell(s, lvl, x, ?w); // Bind region value after call
    assume v >= 0; // From cas_if
    assume w == v + 2; // From cas_to
  }
}

procedure readerRelease2(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl, s, lvl, x, ?n) && n > 0 && RUNLOCK2@r;
  ensures  RWLock(r, alvl, s, lvl, x);
{
  use_region_interpretation RWLock(r, alvl, s, lvl, x);
    // Learn that n > 0 && RUNLOCK2@r implies that n in {2, 3}

  use_atomic
    using RWLock(r, alvl, s, lvl, x) with RUNLOCK2@r;
  {
    assert Cell(s, lvl, x, ?v); // Bind region value before call
    spinCAS(s, lvl, x, Set(2, 3));
      // cas_if := \v -> true
      // cas_to := \v -> v - 2
    assert Cell(s, lvl, x, ?w); // Bind region value after call
    assume true; // From cas_if
    assume w == v - 2; // From cas_to
  }
}

procedure writerAcquire(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl, s, lvl, x) && WLOCK@r;
  ensures  RWLock(r, alvl, s, lvl, x, -1) && WLOCK@r && WUNLOCK@r;
{
  bool b;

  use_atomic
    using RWLock(r, alvl, s, lvl, x) with WLOCK@r;
  {
    assert Cell(s, lvl, x, ?v); // Bind region value before call
    spinCAS(s, lvl, x, Int);
      // cas_if := \v -> v == 0
      // cas_to := \v -> -1
    assert Cell(s, lvl, x, ?w); // Bind region value after call
    assume v == 0; // From cas_if
    assume w == -1; // From cas_to
  }
}

abstract_atomic procedure writerReleaseAA(id s, int lvl, memcell x)
  interference ?m in Set(-1) on s;
  requires Cell(s, lvl, x, m) && G@s;
  ensures  Cell(s, lvl, x, 0) && G@s;
{
  use_atomic
    using Cell(s, lvl, x) with G@s;
  {
    x.f := 0;
  }
}

procedure writerRelease(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl, s, lvl, x, -1) && WUNLOCK@r;
  ensures  RWLock(r, alvl, s, lvl, x);
{
  use_atomic
    using RWLock(r, alvl, s, lvl, x) with WUNLOCK@r;
  {
    writerReleaseAA(s, lvl, x);
  }
}

//
// From Caper/CAPLock
//

predicate Inv() /* Invariant of CAP lock (left abstract) */

region CAPLock(id r, int alvl, id s, int lvl, memcell x)
  guards {
    duplicable Z;
    unique K;
  }
  interpretation {
       Cell(s, lvl, x, ?v) && lvl < alvl && G@s
    && (v == 0 ==> K@r && Inv())
    && (v == 1 ==> true)
  }
  state { v }
  actions {
    Z: 0 ~> 1;
    K: 1 ~> 0;
  }

procedure lock(id r, int alvl, id s, int lvl, memcell x)
  requires CAPLock(r, alvl, s, lvl, x, ?m) && (m in Set(0, 1)) && Z@r;
  ensures  CAPLock(r, alvl, s, lvl, x, ?n) && n == 1 && K@r && Z@r;
{
  use_atomic
    using CAPLock(r, alvl, s, lvl, x) with Z@r;
  {
    assert Cell(s, lvl, x, ?v); // Bind region value before call
    spinCAS(s, lvl, x, Int);
      // cas_if := \v -> v == 0
      // cas_to := \v -> 1
    assert Cell(s, lvl, x, ?w); // Bind region value after call
    assume v == 0; // From cas_if
    assume w == 1; // From cas_to
  }
}

abstract_atomic procedure unlockAA(id s, int lvl, memcell x)
  interference ?v in Set(1) on s;
  requires Cell(s, lvl, x, v) && G@s;
  ensures Cell(s, lvl, x, 0) && G@s;
{
  make_atomic
    using Cell(s, lvl, x) with G@s;
  {
    update_region
      using Cell(s, lvl, x);
    {
      x.f := 0;
    }
  }
}

procedure unlock(id r, int alvl, id s, int lvl, memcell x)
  requires CAPLock(r, alvl, s, lvl, x, ?m) && m == 1 && K@r;
  requires Inv();
{
  use_atomic
    using CAPLock(r, alvl, s, lvl, x) with K@r;
  {
    unlockAA(s, lvl, x);
  }
}



struct memcell {
  int f;
}

primitive_atomic procedure CAS(memcell x, int now, int thn) returns (bool ret)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

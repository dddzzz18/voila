//:: IgnoreFile(/voila/issue/49/)

region Cell(id s, int lvl, memcell x)
  guards { unique G; }
  interpretation { x.f |-> ?v }
  state { v }
  actions {
    G: ?n ~> ?m;
  }

region RWLock(id r, int alvl, id s, int lvl, memcell x)
  guards {
    duplicable WLOCK;
    unique WUNLOCK;
    unique RLOCK1;
    unique RUNLOCK1;
    unique RLOCK2;
    unique RUNLOCK2;
  }
  interpretation {
    Cell(s, lvl, x, ?v) && lvl < alvl && G@s &&
    (v ==  0 ? RUNLOCK1@r && RUNLOCK2@r && WUNLOCK@r :
     v ==  1 ? WUNLOCK@r && RUNLOCK2@r :
     v ==  2 ? WUNLOCK@r && RUNLOCK1@r :
     v ==  3 ? WUNLOCK@r :
     v == -1 ? RUNLOCK1@r && RUNLOCK2@r :
     false)
  }
  state { v }
  actions {
    RLOCK1  :  0 ~>  1;
    RUNLOCK1:  1 ~>  0;
    RLOCK2  :  0 ~>  2;
    RUNLOCK2:  2 ~>  0;
    RLOCK1  :  2 ~>  3;
    RUNLOCK1:  3 ~>  2;
    RLOCK2  :  1 ~>  3;
    RUNLOCK2:  3 ~>  1;
    WLOCK   :  0 ~> -1;
    WUNLOCK : -1 ~>  0;
  }



abstract_atomic procedure readerAcquire1AA(id s, int lvl, memcell x)
  interference ?m in Set(-1, 0, 2) on s;
  requires Cell(s, lvl, x, m) && G@s;
  ensures  Cell(s, lvl, x, ?n) && G@s;
  ensures  m in Set(0, 2) && n == m + 1;
{
  int v;
  bool b;

  make_atomic
    using Cell(s, lvl, x) with G@s;
  {
    do
      invariant Cell(s, lvl, x);
      invariant !b ==> s |=> <D> ;
      invariant  b ==> s |=> (v, v + 1) && (v in Set(0, 2));
    {
      open_region
        using Cell(s, lvl, x);
      {
        v := x.f;
      }

      if (v >= 0) {
        update_region
          using Cell(s, lvl, x);
        {
          b := CAS(x, v, v + 1);
        }
      } else {
        b := false;
      }
    } while (!b);
  }
}

procedure readerAcquire1(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl,  s, lvl, x, ?m) && RLOCK1@r && m != 1 && m != 3;
  ensures  RWLock(r, alvl,  s, lvl, x, ?n) && RLOCK1@r && RUNLOCK1@r && n > 0;
{
  use_region_interpretation RWLock(r, alvl,  s, lvl, x);
    // Learn that m != 1 && m != 3 implies that m in {-1, 0, 2}

  use_atomic
    using RWLock(r, alvl,  s, lvl, x) with RLOCK1@r;
  {
    readerAcquire1AA(s, lvl, x);
  }
}



abstract_atomic procedure readerRelease2AA(id s, int lvl, memcell x)
  interference ?m in Set(2, 3) on s;
  requires Cell(s, lvl, x, m) && G@s;
  ensures  Cell(s, lvl, x, ?n) && G@s;
  ensures  n == m - 2;
{
  int v;
  bool b;

  make_atomic
    using Cell(s, lvl, x) with G@s;
  {
    do
      invariant Cell(s, lvl, x);
      invariant !b ==> s |=> <D>;
      invariant  b ==> s |=> (v, v - 2) && (v in Set(2, 3));
    {
      open_region
        using Cell(s, lvl, x);
      {
        v := x.f;
      }

      update_region
        using Cell(s, lvl, x);
      {
        b := CAS(x, v, v - 2);
      }
    } while (!b);
  }
}

procedure readerRelease2(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl,  s, lvl, x, ?n) && n > 0 && RUNLOCK2@r;
  ensures  RWLock(r, alvl,  s, lvl, x);
{
  use_region_interpretation RWLock(r, alvl,  s, lvl, x);
    // Learn that n > 0 && RUNLOCK2@r implies that n in {2, 3}

  use_atomic
    using RWLock(r, alvl,  s, lvl, x) with RUNLOCK2@r;
  {
    readerRelease2AA(s, lvl, x);
  }
}




abstract_atomic procedure writerAcquireAA(id s, int lvl, memcell x)
  interference ?m in Int on s;
  requires Cell(s, lvl, x, m) && G@s;
  ensures  Cell(s, lvl, x, -1) && G@s;
  ensures  m == 0;
{
  bool b;

  make_atomic
    using Cell(s, lvl, x) with G@s;
  {
    do
      invariant Cell(s, lvl, x);
      invariant !b ==> s |=> <D>;
      invariant  b ==> s |=> (0, -1);
    {
      update_region
        using Cell(s, lvl, x);
      {
        b := CAS(x, 0, -1);
      }
    } while (!b);
  }
}

procedure writerAcquire(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl,  s, lvl, x) && WLOCK@r;
  ensures  RWLock(r, alvl,  s, lvl, x, -1) && WLOCK@r && WUNLOCK@r;
{
  use_atomic
    using RWLock(r, alvl,  s, lvl, x) with WLOCK@r;
  {
    writerAcquireAA(s, lvl, x);
  }
}

abstract_atomic procedure writerReleaseAA(id s, int lvl, memcell x)
  interference ?m in Set(-1) on s;
  requires Cell(s, lvl, x, m) && G@s;
  ensures  Cell(s, lvl, x, 0) && G@s;
{
  use_atomic
    using Cell(s, lvl, x) with G@s;
  {
    x.f := 0;
  }
}

procedure writerRelease(id r, int alvl, id s, int lvl, memcell x)
  requires RWLock(r, alvl,  s, lvl, x, -1) && WUNLOCK@r;
  ensures  RWLock(r, alvl,  s, lvl, x);
{
  use_atomic
    using RWLock(r, alvl,  s, lvl, x) with WUNLOCK@r;
  {
    writerReleaseAA(s, lvl, x);
  }
}



primitive_atomic procedure CAS(memcell x, int now, int thn) returns (bool ret)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

struct memcell {
  int f;
}

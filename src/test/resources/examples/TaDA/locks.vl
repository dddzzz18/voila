struct memcell {
  int f;
}

region Lock(id a, memcell x)
  guards { unique G; }
  interpretation {
    x.f |-> ?v && (v == 0 || v == 1)
  }
  state { v }
  actions {
    G: 0 ~> Set(0, 1);
    G: 1 ~> Set(1, 0);
  }

//predicate U(id a, memcell x) {
//  Lock(a, x, 0) && G@a
//}
//
//predicate L(id a, memcell x) {
//  Lock(a, x, 1) && G@a
//}

predicate Inv() /* Invariant of CAP lock (left abstract) */

region CAPLock(id r, id a, memcell x)
  guards {
    duplicable Z;
    unique K;
  }
  interpretation {
       Lock(a, x, ?v) && G@a // Included in both L(a, x) and U(a, x)
    && (v == 0 ==> K@r && Inv())
    && (v == 1 ==> true)
  }
  state { v }
  actions {
    Z: 0 ~> Set(0, 1);
    K: 1 ~> Set(1, 0);
  }

predicate isLock(id r, id a, memcell x) {
  CAPLock(r, a, x, ?v) && (v in Set(0, 1))
}

predicate Locked(id r, id a, memcell x) {
  CAPLock(r, a, x, ?v) && v == 1 && K@r
}



primitive_atomic procedure CAS(memcell x, int now, int thn) returns (bool ret)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;



abstract_atomic procedure unlock(id a, memcell x)
  interference ?s in Set(1) on a;
  requires Lock(a, x, s) && G@a; // L(a, x)
  ensures Lock(a, x, 0) && G@a; // U(a, x)
{
  // unfold L(a, x);

  make_atomic
    using Lock(a, x) with G@a;
  {
    update_region
      using Lock(a, x);
    {
      x.f := 0;
    }
  }

  // fold U(a, x);
}

procedure non_atomic_unlock(id r, id a, memcell x)
  requires Locked(r, a, x);
  requires Inv();
{
  unfold Locked(r, a, x);
  // unfold CAPLock(r, a, x);
  // fold L(a, x);

  use_atomic
    using CAPLock(r, a, x) with K@r;
  {
    unlock(a, x);
  }
}




abstract_atomic procedure lock(id a, memcell x)
  interference ?s in Set(0, 1) on a;
  // requires s == 0 ? U(a, x) : L(a, x);
  requires Lock(a, x, s) && G@a;
  // ensures L(a, x) && s == 0;
  ensures Lock(a, x, 1) && G@a && s == 0;
{
  bool b;

  // if (s == 0) { unfold U(a, x); }
  // else { unfold L(a, x); }

  make_atomic
    using Lock(a, x) with G@a;
  {
    do
      invariant Lock(a, x);
      invariant !b ==> a |=> <D>;
      invariant  b ==> a |=> (0, 1);
    {
      update_region
        using Lock(a, x);
      {
        b := CAS(x, 0, 1);
      }
    } while (!b);
  }

  // fold L(a, x);
}

procedure non_atomic_lock(id r, id a, memcell x)
  requires isLock(r, a, x) && Z@r;
  ensures  Locked(r, a, x);
  // ensures  isLock(r, a, x);
{
  unfold isLock(r, a, x);

  use_atomic
    using CAPLock(r, a, x) with Z@r;
  {
    lock(a, x);
  }

  fold Locked(r, a, x);
}

//:: IgnoreFile(/voila/issue/53/)

// Misc TODOs. File issues or investigate further.
// TODO: "macro Foo(r, m, a, l, h) MCAS(r, m, a, l, ?h);" parses, but does it work as expected?
// TODO: Change syntax for collection type annotations: from Set[T] to Set<T> (etc.)
// TODO: Support set subtraction, i.e. xs \ ys
// TODO: Support set intersection; with it, we can encode disjoint set union
// TODO: Support predicates with out-args

// Local TODOs:
// TODO: Heap unions should actually be disjoint heap unions!

struct mcas {
  heap _h1; // Witness existentially quantified heap partitions h1, h2 ...
  heap _h2; // ... in the interpretation of the MCAS region
}

//macro heap set<pair<cell, int>>;
macro heap set<cell>;
    // TODO: The paper uses a "real" heap, i.e. a set of points-to predicates, with values


/* TODO: QPAcc represents quantified permissions to x.value for each x in h.
 *       Use actual quantified permissions instead, once supported.
 */
predicate QPAcc(id r, heap h)

/* Unpack permissions to x.value by splitting QPAcc(r, {x} ∪ h2) into x.value |-> _ ⚹ QPAcc(r, h2) */
macro QPAcc_unpack(r, x, h2) {
  exhale QPAcc(r, Set(x) union h2);
  inhale x.value |-> _ && QPAcc(r, h2);
}

/* Re-pack permissions to x.value by joining x.value |-> _ ⚹ QPAcc(r, h2) into QPAcc(r, {x} ∪ h2) */
macro QPAcc_pack(r, x, h2) {
  exhale x.value |-> _ && QPAcc(r, h2);
  inhale QPAcc(r, Set(x) union h2);
}


region MCAS(id r, mcas m, id a, cell l)
  guards {
    duplicable Z;
    /* TODO: Neither unique nor duplicable are an ideal choice for the *four* next guards. See also issue #43. */
      duplicable OWN(cell x);
      duplicable OWNED(heap xs);
      duplicable LOCKED(heap h);
      duplicable KEY(heap h);
    unique UNLOCKED;
  }
  interpretation {
    m._h1 |-> ?h1 && m._h2 |-> ?h2 && // Ghost: Existentially quantified h1, h2
    OWNED(h1 union h2)@r &&
    Lock(a, l, ?s) && G@a && // Contained in U(l) and L(l) (from the locks library)
    (s == 0
        ? UNLOCKED@r   && QPAcc(r, h1 union h2)
        : LOCKED(h1)@r && QPAcc(r, h2))
  }
  state { h1 union h2 }
  actions {
    // Actions from the paper:
      //  ?h, ?x | Z: h ~> h ⚹ x.value |-> v;
      // ?h, ?v, ?w, ?x | OWN(x): x.value |-> v ⚹ h ~> x.value |-> w ⚹ h
      // ?h, ?v, ?x | OWN(x): x.value |-> v ⚹ h ~> h
    // Voila actions:
      // ?h, cell ?x | Z: h ~> Set(x) union h; // TODO: Not yet supported, see issue #51
      // TODO: What about the second action?
      ?h, ?x | OWN(x): Set(x) union h ~> h;
  }


/* lemma */ procedure OWN_exclusivity(id r, cell x)
  requires OWN(x)@r && OWN(x)@r;
  ensures  false;

/* lemma */ procedure OWNED_exclusivity(id r, heap h1, heap h2)
  requires OWNED(h1)@r && OWNED(h2)@r;
  ensures  false;

/* lemma */ procedure UNLOCKED_lock(id r, heap h)
  requires UNLOCKED@r;
  ensures  LOCKED(h)@r && KEY(h)@r;

/* lemma */ procedure UNLOCKED_unlock(id r, heap h)
  requires LOCKED(h)@r && KEY(h)@r;
  ensures  UNLOCKED@r;

/* Follows from the equivalence between UNLOCKED and LOCKED && KEY.
 * Holds for LOCKED as well (instead of KEY), but we don't need that property.
 */
/* lemma */ procedure UNLOCKED_KEY_exclusivity(id r, heap h)
  requires UNLOCKED@r && KEY(h)@r;
  ensures  false;

/* TODO: This appears to be used in proof outlines in the paper, but it is not explicitly stated
 *       and I don't immediately see how it follows from the explicitly stated properties.
 */
/* lemma */ procedure LOCKED_KEY_argument_equality(id r, heap h1, heap h2)
  requires LOCKED(h1)@r && KEY(h2)@r;
  ensures  LOCKED(h1)@r && KEY(h2)@r;
  ensures  h1 == h2;


// TODO: Support predicates (or macros) with out-args
//predicate MCL(id r, mcas m, id a, cell l; heap h) {
//  MCAS(r, m, a, l, h)
//}


// TODO: function makeMCL
// TODO: function makeMCP
// TODO: function unmakeMCP

// TODO: Contract from the paper states that the returned value is the value of x.
//       This might be possible if the MCAS region's heap were a mapping from locations to values.
abstract_atomic procedure read(id r, mcas m, id a, cell l, cell x) returns (int ret)
//  interference ?v in Int on r;
      // TODO: Quantifying over int v currently results in a malformed Viper program because the
      //       encoding assumes that the interference variable quantifies over the abstract state
      //       of the (here: MCAS) region. That's not the case in this example, however.
  interference ?hPre in Set[heap](?h | true) on r; // Allow maximal interference
  requires MCAS(r, m, a, l, hPre) && x in hPre && OWN(x)@r;
  requires Z@r; // TODO: Should not be necessary, see issue #19
  ensures  MCAS(r, m, a, l, ?hPost) && x in hPost && OWN(x)@r;
//  ensures  ret == v; // TODO: Not yet possible because values aren't specified by MCAS
{
  make_atomic
    using MCAS(r, m, a, l) with Z@r;
      // Note: We cannot use OWN(x)@r here since we need it in the body of the rule
  {
    /* ########## lock(a, l); ########## */
    open_region // Open-region suffices since we don't change the region's abstract state
      using MCAS(r, m, a, l);
    {
      /* Acquire the lock at Lock(a, l) and take permissions to x.value out of the MCAS region */
      lock_and_take_permissions(r, m, a, l, x);
    }

    /* ########## ret := [x]; ########## */
    update_region // Open would suffice, but we need to use update-region somewhere in the proof
      using MCAS(r, m, a, l);
    {
      ret := x.value;
    }
    /* Exchange diamond for tracking resource (a work-around for issue #8) */
    fix_issue8_updateregion_noop(r, m, a, l);

    /* ########## unlock(a, l); ########## */
    open_region // No abstract state change
      using MCAS(r, m, a, l);
    {
      /* Release the lock at Lock(a, l) and put permissions to x.value back into the MCAS region */
      unlock_and_return_permissions(r, m, a, l, x);
    }
  }
}

// TODO: 'write' clashes with Viper's keyword; need to sanitise identifiers
abstract_atomic procedure _write(id r, mcas m, id a, cell l, cell x, int w)
//  interference ?v in Int on r; // TODO: See read's comment
  interference ?hPre in Set[heap](?h | true) on r; // Allow maximal interference
  requires MCAS(r, m, a, l, hPre) && x in hPre && OWN(x)@r;
  requires Z@r; // TODO: Should not be necessary, see issue #19
  ensures  MCAS(r, m, a, l, ?hPost) && x in hPost && OWN(x)@r;
//  ensures  (x.value |-> w) in hPost; // TODO: See read's comment
{
  make_atomic
    using MCAS(r, m, a, l) with Z@r;
  {
    /* ########## lock(a, l); ########## */
    open_region // Open-region suffices since we don't change the region's abstract state
      using MCAS(r, m, a, l);
    {
      /* Acquire the lock at Lock(a, l) and take permissions to x.value out of the MCAS region */
      lock_and_take_permissions(r, m, a, l, x);
    }

    /* ########## [x] := w; ########## */
    update_region
      using MCAS(r, m, a, l);
    {
      x.value := w;
    }
    /* Exchange diamond for tracking resource (a work-around for issue #8).
     * Note: if values were part of the region's abstract state (as they eventually should), then
     * the previous update might have changed the region's abstract state.
     */
    fix_issue8_updateregion_noop(r, m, a, l);

    /* ########## unlock(a, l); ########## */
    open_region // No abstract state change
      using MCAS(r, m, a, l);
    {
      /* Release the lock at Lock(a, l) and put permissions to x.value back into the MCAS region */
      unlock_and_return_permissions(r, m, a, l, x);
    }
  }
}

// TODO: function cas

abstract_atomic procedure cas1(id r, mcas m, id a, cell l, cell x, int v1, int v2) returns (bool b)
//  interference ?v in Int on r; // TODO: See read's comment
  interference ?hPre in Set[heap](?h | true) on r; // Allow maximal interference
  requires MCAS(r, m, a, l, hPre) && x in hPre && OWN(x)@r;
  requires Z@r; // TODO: Should not be necessary, see issue #19
  ensures  MCAS(r, m, a, l, ?hPost) && x in hPost && OWN(x)@r;
//  ensures  v == v1 ? b && (x.value |-> v1) in hPost : !b && (x.value |-> v) in hPost // TODO: See read's comment
{
  int v0;

  make_atomic
    using MCAS(r, m, a, l) with Z@r;
  {
    /* ########## lock(a, l); ########## */
    open_region // Open-region suffices since we don't change the region's abstract state
      using MCAS(r, m, a, l);
    {
      /* Acquire the lock at Lock(a, l) and take permissions to x.value out of the MCAS region */
      lock_and_take_permissions(r, m, a, l, x);
    }

    /* ########## v0 := [x]; ########## */
    open_region
      using MCAS(r, m, a, l);
    {
      v0 := x.value;
    }

    if (v0 == v1) {
      /* ########## [x] := v2; ########## */
      update_region
        using MCAS(r, m, a, l);
      {
        x.value := v2;
      }
      /* Exchange diamond for tracking resource (a work-around for issue #8).
       * Note: if values were part of the region's abstract state (as they eventually should), then
       * the previous update might have changed the region's abstract state.
       */
      fix_issue8_updateregion_noop(r, m, a, l);

      b := true;
    } else {
      b := false;
      /* Exchange diamond for tracking resource (a work-around for issue #8) */
      fix_issue8_updateregion_noop(r, m, a, l);
    }

    /* ########## unlock(a, l); ########## */
    open_region // No abstract state change
      using MCAS(r, m, a, l);
    {
      /* Release the lock at Lock(a, l) and put permissions to x.value back into the MCAS region */
      unlock_and_return_permissions(r, m, a, l, x);
    }
  }
}

// TODO: function dcas

/* Acquire the lock at Lock(a, l) and take permissions to x.value out of region MCAS(r, ...) */
macro lock_and_take_permissions(r, m, a, l, x) {
  /* Learn that the lock's state is in {0, 1} */
  use_region_interpretation Lock(a, l);

  lock(a, l);

  /* OWN(x)@r ensures that x is still protected by MCAS(r, ..., h), i.e. that x in h */
  fix_duplicable_OWN_guard(r, m, x);

  /* Exchange UNLOCKED@r for LOCKED(Set(x))@r and KEY(Set(x))@r */
  use UNLOCKED_lock(r, Set(x));

  /* Take permissions to x.value out of the MCAS region */
  take_permissions_out(r, m, x);
}

/* Release the lock at Lock(a, l) and put permissions to x.value back into region MCAS(r, ...) */
macro unlock_and_return_permissions(r, m, a, l, x) {
  learn_lock_held_from_KEY(r, Set(x), a, l);

  unlock(a, l);

  /* At this point we know that
   *   (1) x.value |-> _ ⚹ KEY({x})@r
   *   (2) ∃ h1, h2 :: LOCKED(h1)@r ⚹ QPAcc(r, h2) ⚹ h == h1 ∪ h2
   * where h is the abstract state of the region.
   */

  /* Recover that permissions to x.value have been taken out of the region.
   * I.e. learn from from KEY(Set(x))@r ⚹ LOCKED(h1)@r that h1 == {x}.
   */
  assert m._h1 |-> ?h1_1;
  use LOCKED_KEY_argument_equality(r, h1_1, Set(x));

  /* Exchange LOCKED(Set(x))@r ⚹ KEY(Set(x))@r for UNLOCKED@r */
  use UNLOCKED_unlock(r, Set(x));

  /* Give permissions to x.value back to the MCAS region*/
  give_permissions_back(r, m, x);
}

/* Take permissions to x.value out of region MCAS(r, ..., h). This requires partitioning h into
 * {x} and h2, and splitting QPAcc(h) into x.value |-> _ ⚹ QPAcc(h2).
 */
macro take_permissions_out(r, m, x) {
  /* Havoc ghost fields (existential heap partition witnesses) and bind pre- and post-havoc values */
  exhale m._h1 |-> ?h1_0;
  exhale m._h2 |-> ?h2_0;
  inhale m._h1 |-> ?h1_1;
  inhale m._h2 |-> ?h2_1;

  /* Check that permissions to x are still in the region */
  assert x in h1_0 union h2_0;
  assert QPAcc(r, h1_0 union h2_0);

  /* The region holds permissions to all y.value in h, via QPAcc(r, h). Permissions to x.value can
   * be taken out by partitioning h into h1 := {x} and h2 := h \ {x}. This requires constraining
   * the new values of the existential witnesses appropriately.
   */
  inhale h1_1 == Set(x);
  inhale h1_1 union h2_1 == h1_0 union h2_0;
    /* TODO: We want h2_1 := h2_0 \ Set(x), but set minus is not yet supported.
     *       Note that we overapproximate h2_1 here because the constrain allows h2_1 to overlap
     *       with h1_1. This is sound, however, since we don't know for sure that the two overlap.
     */

  /* Finally, unpack permissions to x.value from QPAcc */
  QPAcc_unpack(r, x, h2_1);
}

/* Give permissions to x.value back to region MCAS(r, ..., {x} ∪ h2). This requires changing the
 * partitioning of h from {x} and h2 to {} and {x} ∪ h2, and combining x.value |-> _ ⚹ QPAcc(h2)
 * into QPAcc({x} ∪ h2).
 */
macro give_permissions_back(r, m, x) {
  /* Havoc existential heap partition witnesses and bind their pre- and post-havoc values */
  exhale m._h1 |-> ?h1_1;
  inhale m._h1 |-> ?h1_2;
  exhale m._h2 |-> ?h2_1;
  inhale m._h2 |-> ?h2_2;

  /* Constraint witnesses */
  inhale h1_2 == Set[cell]();
  inhale h2_2 == h1_1 union h2_1;

  /* Finally, pack permissions to x.value back into QPAcc */
  QPAcc_pack(r, x, h2_1);
}

/* Learn from KEY(h)@r that we hold Lock(a, l) */
macro learn_lock_held_from_KEY(r, h, a, l) {
  assert Lock(a, l, ?s1);
  use_region_interpretation Lock(a, l); // Learn that s1 in {0, 1}
  if (s1 == 0) { // Cannot hold; but we need ghost code to prune this proof branch.
    use UNLOCKED_KEY_exclusivity(r, h);
  }
}

/* Holding OWN(x)@r guarantees that no other thread can remove x from the protection of
 * MCAS(r, m, ...). OWN is currently marked as duplicable, however (although OWN(x)@r, for a given
 * x and r, is unique) and to account for this, we assert that OWN(x)@r is held and then add the
 * assumption that x is still protected.
 */
macro fix_duplicable_OWN_guard(r, m, x) {
  assert OWN(x)@r;
  assert m._h1 |-> ?h1 && m._h2 |-> ?h2;
  assume x in h1 union h2;
}

/* Work around issue #8 by manually exchanging the diamond resource r |=> <D> for the tracking
 * resource r |=> (h, h), where h is the abstract state of MCAS(r, ...).
 */
macro fix_issue8_updateregion_noop(r, m, a, l) {
  unfold MCAS(r, m, a, l);
  assert m._h1 |-> ?h1 && m._h2 |-> ?h2;
  exhale r |=> <D>;
  inhale r |=> (h1 union h2, h1 union h2);
  fold MCAS(r, m, a, l);
}

/*
 * Locks library
 */

struct cell {
  int value;
}

region Lock(id a, cell x)
  guards { unique G; }
  interpretation {
    x.value |-> ?v && (v == 0 || v == 1)
  }
  state { v }
  actions {
    G: 0 ~> 1;
    G: 1 ~> 0;
  }

abstract_atomic procedure unlock(id a, cell x)
  interference ?s in Set(1) on a;
  requires Lock(a, x, s) && G@a;
  ensures Lock(a, x, 0) && G@a;

abstract_atomic procedure lock(id a, cell x)
  interference ?s in Set(0, 1) on a;
  requires Lock(a, x, s) && G@a;
  ensures Lock(a, x, 1) && G@a && s == 0;

primitive_atomic procedure CAS(cell x, int now, int thn) returns (bool ret)
  requires x.value |-> ?v;
  ensures  v == now
              ? ret && x.value |-> thn
              : !ret && x.value |-> v;

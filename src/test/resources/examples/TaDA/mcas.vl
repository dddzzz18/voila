// TODO: It seems that the procedures are not forced to release the lock at Lock(a, l).
//       Could that also happen in the paper proofs? I think so - maybe Pedro's thesis says sth. about that?
//       Could we include the lock state in the abstract state of the MCAS region to prevent this?


macro heap map<cell, int>; // Let heap be type alias for maps from cells to ints

/* The mcas struct has ghost fields only and does not correspond to anything in the paper proof. */
struct mcas {
  heap _h1; // Witness existentially quantified heap partitions h1, h2 ...
  heap _h2; // ... in the interpretation of the MCAS region
}


/* TODO: QPAcc represents quantified permissions to x.value for each x in h and constitutes a
 *       work-around for not yet supporting quantified permissions (issue #56). Once supported,
 *       I expect that we can simplify the encoding quite a bit.
 */
predicate QPAcc(id r, heap h)

/* Unpack permissions to x.value by splitting QPAcc(r, {x -> v} ⊎ h2) into x.value |-> v ⚹ QPAcc(r, h2) */
macro QPAcc_unpack(r, x, v, h2) {
  exhale QPAcc(r, uni(Map(x := v), h2));
  inhale x.value |-> v && QPAcc(r, h2);
}

/* Re-pack permissions to x.value by joining x.value |-> v ⚹ QPAcc(r, h2) into QPAcc(r, {x -> v} ⊎ h2) */
macro QPAcc_pack(r, x, v, h2) {
  exhale x.value |-> v && QPAcc(r, h2);
  inhale QPAcc(r, uni(Map(x := v), h2));
}


region MCAS(id r, mcas m, id a, cell l)
  guards {
    duplicable Z;
    /* TODO: Neither unique nor duplicable are an ideal choice for the *four* next guards. See also issue #43. */
      duplicable OWN(cell x);
      duplicable OWNED(set<cell> xs);
      duplicable LOCKED(heap h);
      duplicable KEY(heap h);
    unique UNLOCKED;
  }
  interpretation {
    m._h1 |-> ?h1 && m._h2 |-> ?h2 && disj(h1, h2) && // Ghost: Existentially quantified h1, h2
    OWNED(keys(h1) union keys(h2))@r &&
    Lock(a, l, ?s) && G@a && // Contained in U(l) and L(l) (from the locks library)
    (s == 0
        ? UNLOCKED@r   && QPAcc(r, uni(h1, h2))
        : LOCKED(h1)@r && QPAcc(r, h2))
  }
  state { uni(h1, h2) }
  actions {
    // Actions from the paper:
      // ?h, ?x, ?v | Z: h ~> h ⚹ x.value |-> v;
      // ?h, ?v, ?w, ?x | OWN(x): x.value |-> v ⚹ h ~> x.value |-> w ⚹ h
      // ?h, ?v, ?x | OWN(x): x.value |-> v ⚹ h ~> h

    // Corresponding Voila actions:
      // heap ?h, cell ?x, int ?v | Z: h ~> uni(Map(x := v), h); // TODO: Not yet supported, see issue #51
      // heap ?h, cell ?x, int ?v, int ?w | OWN(x): uni(Map(x := v), h) ~> uni(Map(x := w), h); // TODO: Not yet supported, see issue #51
      // heap ?h, cell ?x, int ?v | OWN(x): uni(Map(x := v), h) ~> h; // TODO: Not yet supported, see issue #51
      //
      // TODO: The next action might be an alternative encoding of action 2 from above
      //       that would not require fully supporting injective actions. However, it does require
      //       support for Map_items.
      // heap ?h0, heap ?h1, cell ?x |
      //   x in keys(h0) && keys(h1) == keys(h0) && items(h1) == Set(pair<cell, int> ?p | fst(p) != x ==> snd(p) == lkup(h0, fst(p))) |
      //     OWN(x): h0 ~> h1;

    // TODO: Since we cannot yet encode the actual actions, we work around it by allowing more state
    //       changes and "fixing" this by adding additional assumptions in the procedures to verify.
    ?h0, ?h1 | Z: h0 ~> h1;
  }


/* lemma */ procedure OWN_exclusivity(id r, cell x)
  requires OWN(x)@r && OWN(x)@r;
  ensures  false;

/* lemma */ procedure OWNED_exclusivity(id r, set<cell> cs1, set<cell> cs2)
  requires OWNED(cs1)@r && OWNED(cs2)@r;
  ensures  false;

/* lemma */ procedure UNLOCKED_lock(id r, heap h)
  requires UNLOCKED@r;
  ensures  LOCKED(h)@r && KEY(h)@r;

/* lemma */ procedure UNLOCKED_unlock(id r, heap h)
  requires LOCKED(h)@r && KEY(h)@r;
  ensures  UNLOCKED@r;

/* Follows from the equivalence between UNLOCKED and LOCKED && KEY.
 * Holds for LOCKED as well (instead of KEY), but we don't need that property.
 */
/* lemma */ procedure UNLOCKED_KEY_exclusivity(id r, heap h)
  requires UNLOCKED@r && KEY(h)@r;
  ensures  false;

/* TODO: This appears to be used in proof outlines in the paper, but it is not explicitly stated
 *       and I don't immediately see how it follows from the explicitly stated properties.
 */
/* lemma */ procedure LOCKED_KEY_argument_equality(id r, heap h1, heap h2)
  requires LOCKED(h1)@r && KEY(h2)@r;
  ensures  LOCKED(h1)@r && KEY(h2)@r;
  ensures  h1 == h2;


// TODO: function makeMCL

// TODO: function makeMCP

// TODO: function unmakeMCP

/* A note on the interference specification of the following procedures: the paper proofs
 * interference-quantify over the value of cell x and existentially quantify (via the MCP predicate)
 * over the rest of the heap that is under the MCAS region's protection. E.g.
 *   \forall v exists h :: MCAS(... x.value |-> v ⚹ h) && 0 < v
 * I.e. the region's abstract state is composed from interference-quantified and existentially
 * quantified state.
 * Voila currently expects that an interference-quantification directly ranges over abstract region
 * state and thus does not support the former. In this MCAS encoding, I therefore
 * interference-quantify over the whole abstract state instead and then project that state down to
 * the value of x, whenever needed. E.g.
 *   \forall h :: MCAS(... h) && 0 < h(x)
 * As far as I can see (for this example), this results in equally strong specifications.
 */

abstract_atomic procedure read(id r, mcas m, id a, cell l, cell x) returns (int ret)
  interference ?h0 in Set[heap](?u | true) on r;
  requires MCAS(r, m, a, l, h0) && x in keys(h0) && OWN(x)@r;
  requires Z@r; // TODO: Should not be necessary, see issue #19
  ensures  MCAS(r, m, a, l, ?h1) && x in keys(h1) && OWN(x)@r;
  ensures  lkup(h1, x) == lkup(h0, x);
  ensures  ret == lkup(h0, x);
{
  make_atomic
    using MCAS(r, m, a, l) with Z@r; // TODO: Use OWN(x) here, once the MCAS actions have been properly encoded
  {
    /* ########## lock(a, l); ########## */
    open_region // Open-region suffices since we don't change the region's abstract state
      using MCAS(r, m, a, l);
    {
      /* Acquire the lock at Lock(a, l) and take permissions to x.value (with abstract value h0(x))
       * out of region MCAS(r, m, a, l).
       */
      lock_and_take_permissions(r, m, a, l, x, lkup(h0, x));
    }

    /* ########## ret := [x]; ########## */
    open_region
      using MCAS(r, m, a, l);
    {
      ret := x.value;
    }

    /* ########## unlock(a, l); ########## */
    assert MCAS(r, m, a, l, ?hPreUpdRgn); /* TODO: Issue #8*/
    update_region
      using MCAS(r, m, a, l);
    {
      /* Release the lock at Lock(a, l) and put permissions to x.value back into the MCAS region,
       * which (potentially) modifies the region's abstract state. This (currently) requires knowing
       * the old (second-to-last argument) and the new (last argument) abstract value of x, both of
       * which are in this case both h0(x).
       */
      unlock_and_return_permissions(r, m, a, l, x, lkup(h0, x), lkup(h0, x));
    }
    /* TODO: To work around issue #8, we explicitly exchange the diamond for the tracking resource
     *       if the abstract state wasn't changed inside the update-region block
     */
    assert MCAS(r, m, a, l, ?hPostUpdRgn);
    if (hPreUpdRgn == hPostUpdRgn) {
      fix_issue8_updateregion_noop(r, m, a, l);
    }
  }
}

/* TODO: 'write' clashes with Viper's keyword; need to sanitise identifiers. See issue #58. */
abstract_atomic procedure _write(id r, mcas m, id a, cell l, cell x, int w)
  interference ?h0 in Set[heap](?u | true) on r; // TODO: See read's comment
  requires MCAS(r, m, a, l, h0) && x in keys(h0) && OWN(x)@r;
  requires Z@r; // TODO: See read's comment
  ensures  MCAS(r, m, a, l, ?h1) && x in keys(h1) && OWN(x)@r;
  ensures  lkup(h1, x) == w; // TODO: Specs could be more concise, see issue #59
{
  make_atomic
    using MCAS(r, m, a, l) with Z@r; // TODO: See read's comment
  {
    /* ########## lock(a, l); ########## */
    open_region
      using MCAS(r, m, a, l);
    {
      lock_and_take_permissions(r, m, a, l, x, lkup(h0, x));
    }

    /* ########## [x] := w; ########## */
    open_region
      using MCAS(r, m, a, l);
    {
      x.value := w;
    }

    /* ########## unlock(a, l); ########## */
    assert MCAS(r, m, a, l, ?hPreUpdRgn); // TODO: See read's comment
    update_region
      using MCAS(r, m, a, l);
    {
      unlock_and_return_permissions(r, m, a, l, x, lkup(h0, x), w);
    }
    /* TODO: See read's comment */
    assert MCAS(r, m, a, l, ?hPostUpdRgn);
    if (hPreUpdRgn == hPostUpdRgn) {
      fix_issue8_updateregion_noop(r, m, a, l);
    }
  }
}

abstract_atomic procedure cas1(id r, mcas m, id a, cell l, cell x, int w1, int w2) returns (bool b)
  interference ?h0 in Set[heap](?u | true) on r; // TODO: See read's comment
  requires MCAS(r, m, a, l, h0) && x in keys(h0) && OWN(x)@r;
  requires Z@r; // TODO: See read's comment
  ensures  MCAS(r, m, a, l, ?h1) && x in keys(h1) && OWN(x)@r;
  ensures  b <==> lkup(h0, x) == w1;
  ensures  b ? lkup(h1, x) == w2 : lkup(h1, x) == lkup(h0, x);
{
  int v;

  make_atomic
    using MCAS(r, m, a, l) with Z@r; // TODO: See read's comment
  {
    /* ########## lock(a, l); ########## */
    open_region
      using MCAS(r, m, a, l);
    {
      lock_and_take_permissions(r, m, a, l, x, lkup(h0, x));
    }

    /* ########## v := [x]; ########## */
    open_region
      using MCAS(r, m, a, l);
    {
      v := x.value;
    }

    if (v == w1) {
      /* ########## [x] := w2; ########## */
      open_region
        using MCAS(r, m, a, l);
      {
        x.value := w2;
      }
      b := true;
    } else {
      b := false;
    }

    /* ########## unlock(a, l); ########## */
    assert MCAS(r, m, a, l, ?hPreUpdRgn); /* TODO: Issue #8*/
    update_region
      using MCAS(r, m, a, l);
    {
      unlock_and_return_permissions(r, m, a, l, x, lkup(h0, x), b ? w2 : lkup(h0, x));
    }
    /* TODO: See read's comment */
    assert MCAS(r, m, a, l, ?hPostUpdRgn);
    if (hPreUpdRgn == hPostUpdRgn) {
      fix_issue8_updateregion_noop(r, m, a, l);
    }
  }
}

// TODO: function dcas


/* Acquire the lock at Lock(a, l) and take x.value |-> v out of region MCAS(r, m, a, l) */
macro lock_and_take_permissions(r, m, a, l, x, v) {
  /* Learn that the lock's state is in {0, 1} */
  use_region_interpretation Lock(a, l);

  lock(a, l);

  /* OWN(x)@r ensures that x is still protected by MCAS(r, ..., h), i.e. that x in h */
  fix_duplicable_OWN_guard(r, m, x);

  /* Exchange UNLOCKED@r for LOCKED({x -> v})@r and KEY({x -> v})@r */
  use UNLOCKED_lock(r, Map(x := v));

  /* Take x.value |-> v out of the MCAS region */
  take_permissions_out(r, m, x, v);
}

/* Take x.value |-> v out of region MCAS(r, ..., h). This requires partitioning h into
 * h1 ≡ {x -> v} and h2, and splitting QPAcc(r, h) into x.value |-> _ ⚹ QPAcc(r, h2).
 */
macro take_permissions_out(r, m, x, v) {
  /* Havoc ghost fields (existential heap partition witnesses) and bind pre- and post-havoc values */
  exhale m._h1 |-> ?h1_0;
  exhale m._h2 |-> ?h2_0;
  inhale m._h1 |-> ?h1_1;
  inhale m._h2 |-> ?h2_1;

  /* Check that permissions to x are still in the region */
  assert x in keys(h1_0) union keys(h2_0);
  assert QPAcc(r, uni(h1_0, h2_0));

  /* The region holds y.value |-> _ in h, via QPAcc(r, h). Assertion x.value |-> v can be taken out
   * by partitioning h into h1 ≡ {x -> v} and h2 := h \ {x -> _}. This requires constraining
   * the new values of the existential witnesses appropriately.
   */
  inhale h1_1 == Map(x := v);
  /* TODO: We want h2_1 := h2_0 \ Map(x := v), but map subtraction is not yet supported (issue #59) */
  inhale uni(h1_1, h2_1) == uni(h1_0, h2_0);

  /* TODO: We know h1_0 and h2_0 are disjoint, but we currently don't know that h1_1 and h2_1 are
   *       as well. This might no longer be an issue once map subtraction is used above.
   */
  assert disj(h1_0, h2_0); // This we know
  assume disj(h1_1, h2_1); // This should follow

  /* Finally, unpack x.value |-> v from QPAcc */
  QPAcc_unpack(r, x, v, h2_1);
}

/* Release the lock at Lock(a, l) and put x.value |-> v1 back into region MCAS(r, m, a, l).
 * This currently requires knowing the old (abstract) state of x.value, denoted by v0.
 */
macro unlock_and_return_permissions(r, m, a, l, x, v0, v1) {
  learn_lock_held_from_KEY(r, Map(x := v0), a, l);

  unlock(a, l);

  /* At this point we know that
   *   (1) x.value |-> v1 ⚹ KEY({x -> v0})@r
   *   (2) ∃ h1, h2 :: LOCKED(h1)@r ⚹ QPAcc(r, h2)
   */

  /* Recover that x.value |-> v0 had been taken out of the region.
   * I.e. learn from from KEY({x -> v0})@r ⚹ LOCKED(h1)@r that h1 == {x -> v0}.
   */
  assert m._h1 |-> ?h1_1;
  use LOCKED_KEY_argument_equality(r, h1_1, Map(x := v0));

  /* Exchange LOCKED({x -> v0})@r ⚹ KEY({x -> v0})@r for UNLOCKED@r */
  use UNLOCKED_unlock(r, Map(x := v0));

  /* Put x.value |-> v1 back into the MCAS region */
  give_permissions_back(r, m, x, v0, v1);
}

/* Put x.value |-> v1 back into region MCAS(r, ..., h ≡ h1 ⊎ h2), where h1 ≡ {x -> v0}. This
 * requires changing the partitioning of h ≡ h1 ⊎ h2 to h ≡ h1' ⊎ h2', where h1' ≡ {} and
 * h2' ≡ ({x -> v0} ⊎ h2), and combining x.value |-> v1 ⚹ QPAcc(r, h2) to QPAcc(r, {x -> v1} ⊎ h2).
 */
macro give_permissions_back(r, m, x, v0, v1) {
  /* Havoc existential heap partition witnesses and bind their pre- and post-havoc values */
  exhale m._h1 |-> ?h1_1;
  inhale m._h1 |-> ?h1_2;
  exhale m._h2 |-> ?h2_1;
  inhale m._h2 |-> ?h2_2;

  /* Constraint witnesses */
  inhale h1_2 == Map[cell, int]();
  inhale h2_2 == uni(Map(x := v1), h2_1);

  assert h1_1 == Map(x := v0); // [DEBUG]
  assert h1_2 == Map[cell, int](); // [DEBUG]
  assert h2_2 == uni(Map(x := v1), h2_1); // [DEBUG]
  assert disj(h1_2, h2_2); // [DEBUG]
  assume h2_2 == uni(h1_2, h2_2); // TODO: Should follow from previous assertions, but currently doesn't. See issue #59.

  /* Finally, pack x.value |-> v1 back into QPAcc */
  QPAcc_pack(r, x, v1, h2_1);
}

/* Learn from KEY(h)@r that we hold Lock(a, l), i.e. that the lock's abstract state is 0 */
macro learn_lock_held_from_KEY(r, h, a, l) {
  assert Lock(a, l, ?s);
  use_region_interpretation Lock(a, l); // Learn that s1 in {0, 1}
  if (s == 0) { // Cannot hold; but we need ghost code to prune this proof branch.
    use UNLOCKED_KEY_exclusivity(r, h);
  }
}

/* Holding OWN(x)@r guarantees that no other thread can remove x from the protection of
 * MCAS(r, m, ...). OWN is currently marked as duplicable, however (although OWN(x)@r, for a given
 * x and r, is unique) and further, the MCAS actions are currently not restrictive enough due to
 * encoding limitations. To account for this, we assert that OWN(x)@r is held and then add the
 * assumption that x is still protected.
 */
macro fix_duplicable_OWN_guard(r, m, x) {
  assert OWN(x)@r;
  assert m._h1 |-> ?h1 && m._h2 |-> ?h2;
  assume x in keys(h1) union keys(h2);
}

/* Work around issue #8 by manually exchanging the diamond resource r |=> <D> for the tracking
 * resource r |=> (h, h), where h is the abstract state of MCAS(r, m, a, l).
 */
macro fix_issue8_updateregion_noop(r, m, a, l) {
  assert MCAS(r, m, a, l, ?h);
  exhale r |=> <D>;
  inhale r |=> (h, h);
}

/*
 * Locks library
 */

struct cell {
  int value;
}

region Lock(id a, cell x)
  guards { unique G; }
  interpretation {
    x.value |-> ?v && (v == 0 || v == 1)
  }
  state { v }
  actions {
    G: 0 ~> 1;
    G: 1 ~> 0;
  }

abstract_atomic procedure unlock(id a, cell x)
  interference ?s in Set(1) on a;
  requires Lock(a, x, s) && G@a;
  ensures Lock(a, x, 0) && G@a;

abstract_atomic procedure lock(id a, cell x)
  interference ?s in Set(0, 1) on a;
  requires Lock(a, x, s) && G@a;
  ensures Lock(a, x, 1) && G@a && s == 0;

primitive_atomic procedure CAS(cell x, int now, int thn) returns (bool ret)
  requires x.value |-> ?v;
  ensures  v == now
              ? ret && x.value |-> thn
              : !ret && x.value |-> v;

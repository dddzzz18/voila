struct cell {
  int f;
}

region Counter(id c, cell x)
  guards { unique G; }
  interpretation { x.f |-> ?n }
  state { n }
  actions { G: ?m ~> Int; }

abstract_atomic procedure read(id c, cell x) returns (int ret)
  interference ?n in Int on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n) && G@c;
  ensures ret == n;

abstract_atomic procedure incr(id c, cell x)
  interference ?n in Int on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n + 1) && G@c;


/*
 * Corresponds to Fig. 7.2 from Pedro's thesis
 */
procedure seq_client(id c, cell x, int n)
  requires 0 < n;
  requires Counter(c, x, 0) && G@c;
  ensures  Counter(c, x, n) && G@c;
{
  int m;
  m := n;

  while (0 < m)
    invariant 0 <= m;
    invariant Counter(c, x, n - m) && G@c;
  {
    incr(c, x);
    m := m - 1;
  }
}


/*
 * An encoding of Fig. 7.3 from Pedro's thesis
 */

region CClient(id a, id c, cell x)
  guards {
//    duplicable INC(int k, perm p);
    duplicable xINC;
//    unique TOTAL(int n);
  }
  interpretation {
//    Counter(c, x, ?n) && TOTAL(n)@a;
    Counter(c, x, ?n) && G@c && TOTAL(a, n)
  }
  state { n }
  actions {
//    INC(?k, ?p): k ~> Set(?kk | k < kk);
    xINC: ?k ~> Set(?kk | k < kk);
  }

predicate INC(id a, int k/*, perm p*/)
predicate TOTAL(id a, int n/*, perm p*/)

/* lemma */ procedure INC_split(id a, int k1, int k2/*, perm p1, perm p2*/)
  requires INC(a, k1 + k2/*, p1 + p2*/);
  ensures  INC(a, k1/*, p1*/) && INC(a, k2/*, p2*/);

/* lemma */ procedure INC_join(id a, int k1, int k2/*, perm p1, perm p2*/)
  requires INC(a, k1/*, p1*/) && INC(a, k2/*, p2*/);
  ensures  INC(a, k1 + k2/*, p1 + p2*/);

/* lemma */ procedure TOTAL_INC_equality(id a, int n, int k)
  requires TOTAL(a, n) && INC(a, k/*, 1*/);
//  requires TODO: ... and the composition must be defined
  ensures  TOTAL(a, n) && INC(a, k/*, 1*/);
  ensures  n == k;

/* lemma */ procedure TOTAL_INC_update(id a, int n, int k0, int k1/*, perm p*/)
  requires TOTAL(a, n + k0) && INC(a, k0/*, p*/);
  ensures  TOTAL(a, n + k1) && INC(a, k1/*, p*/);

/* Specialised version of (i.e. derived from) TOTAL_INC_update */
/* lemma */ procedure TOTAL_INC_inc(id a, int n, int k/*, perm p*/)
  requires TOTAL(a, n) && INC(a, k/*, p*/) && 0 <= n - k;
  ensures  TOTAL(a, n + 1) && INC(a, k + 1/*, p*/);
{
  int m;
  assume n == m + k;
  use TOTAL_INC_update(a, m, k, k + 1);
}

/* The parallelly-composed code of Fig. 7.3 */
procedure single_client(id a, id c, cell x) returns (int n)
  requires CClient(a, c, x, ?v0) && INC(a, 0/*, 1/2*/) && 0 <= v0;
  requires xINC@a;
  ensures  CClient(a, c, x,  _) && INC(a, n/*, 1/2*/) && 0 <= n;
{
  int i;

  // n := random();
  havoc n;
  assume 0 <= n;

  i := 0;

  while (i < n)
    invariant 0 <= i && i <= n;
    invariant CClient(a, c, x, ?vi) && i <= vi;
    invariant INC(a, i/*, 1/2*/);
    invariant xINC@a;
  {
    use_atomic
      using CClient(a, c, x) with xINC@a;
    {
      assert Counter(c, x, ?v);
      incr(c, x);
      assert Counter(c, x, v + 1); // [DEBUG]
      assert TOTAL(a, v) && INC(a, i); // [DEBUG]
      use TOTAL_INC_inc(a, v, i);
    }

    i := i + 1;
  }

  assert INC(a, n);
}

/* Main code of Fig. 7.3 */
procedure client() {
  id a, c;
  cell x;
  int k1;
  int k2;

  // x := makeCounter();
  inhale Counter(c, x, 0) && G@c;
  // Create a new CClient region
  inhale TOTAL(a, 0) && INC(a, 0/*, 1*/);
  inhale xINC@a;
  fold CClient(a, c, x, 0);

  // Duplicate region assertion
  assert CClient(a, c, x);
  inhale CClient(a, c, x);
  // Duplicate fake guard xINC
  assert xINC@a;
  inhale xINC@a;
  // Split encoded guard INC
  use INC_split(a, 0, 0);

  // Fork two instances of single_client(a, c, x)
  exhale CClient(a, c, x, ?v01) && INC(a, 0/*, 1/2*/) && 0 <= v01 && xINC@a;
  exhale CClient(a, c, x, ?v02) && INC(a, 0/*, 1/2*/) && 0 <= v02 && xINC@a;

  skip; // Account for possible interference between forking and joining

  // Join the two forked instances of single_client(a, c, x)
  havoc k1;
  inhale CClient(a, c, x, _) && INC(a, k1/*, 1/2*/) && 0 <= k1;
  havoc k2;
  inhale CClient(a, c, x, _) && INC(a, k2/*, 1/2*/) && 0 <= k2;

  // Join encoded guard INC
  use INC_join(a, k1, k2);
  // Transform CClient assertion according to guard algebra (view shift?)
  unfold CClient(a, c, x, _);
  assert Counter(c, x, ?n);
  use TOTAL_INC_equality(a, n, k1 + k2);
  fold CClient(a, c, x, k1 + k2);
  // Dispose CClient region
  unfold CClient(a, c, x, k1 + k2);

  // Postcondition of Fig. 7.3
  exhale Counter(c, x, k1 + k2);
}

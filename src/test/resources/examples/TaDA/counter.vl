struct memcell {
  int f;
}

region Counter(id c, memcell x)
  guards { unique G; }
  interpretation {
    x.f |-> ?n /* Note: In the TaDA paper, n is a natural number (i.e. non-negative) */
  }
  state { n }
  actions {
    G: ?n ~> ?m;
  }


abstract_atomic procedure read(id c, memcell x) returns (int ret)
  interference ?n in Int on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n) && G@c;
  ensures ret == n;
{
  //:: UnexpectedOutput(make-atomic_error:tracking_permission_error, /voila/issue/8/)
  make_atomic
    using Counter(c, x) with G@c;
  {
    update_region
      using Counter(c, x);
    {
      ret := x.f;
    }
  }
}

abstract_atomic procedure read2(id c, memcell x) returns (int ret)
  interference ?n in Int on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n) && G@c;
  ensures ret == n;
{
  open_region
    using Counter(c, x);
  {
    ret := x.f;
  }
}

primitive_atomic procedure CAS(memcell x, int now, int thn) returns (bool ret)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

abstract_atomic procedure incr(id c, memcell x)
  interference ?n in Int on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n + 1) && G@c;
{
  int r;
  bool b;

  make_atomic
    using Counter(c, x) with G@c;
  {
    do
      invariant Counter(c, x);
      invariant !b ==> c |=> <D>;
      invariant  b ==> c |=> (r, r + 1);
    {
      open_region
        using Counter(c, x);
      {
        r := x.f;
      }
      update_region
        using Counter(c, x);
      {
        b := CAS(x, r, r + 1);
      }
    } while (!b);
  }
}

abstract_atomic procedure wkincr(id c, memcell x)
  interference ?n in Set[int](n) on c;
  requires Counter(c, x, n) && G@c;
  ensures Counter(c, x, n + 1) && G@c;
{
  int r;

  make_atomic
    using Counter(c, x) with G@c;
  {
    open_region
      using Counter(c, x);
    {
      r := x.f;
    }

    update_region
      using Counter(c, x);
    {
      x.f := r + 1;
    }
  }
}

region Cell(id s, memcell x)
  guards { unique G; }
  interpretation { x.f |-> ?v }
  state { v }
  actions {
    G: ?m ~> Int;
  }

//abstract_atomic void spinCAS(id s,
//                             memcell x,
//                             set<int> from,
//                             lambda<bool(int)> cas_if,
//                             lambda<int(int)> cas_to)
//  interference ?m in from on s;
//  requires Cell(s, x, m) && G@s;
//  ensures  Cell(s, x, ?n) && G@s;
//  ensures  m in from && cas_if(m);
//  ensures  n == cas_to(m);
//{
//  int v;
//  bool b;
//
//  make_atomic
//    using Cell(s, x) with G@s;
//  {
//    do
//      invariant Cell(s, x);
//      invariant !b ==> s |=> <D>;
//      invariant  b ==> s |=> (v, cas_to(v)) && (v in from) && cas_if(v);
//    {
//      open_region
//        using Cell(s, x);
//      {
//        v := x.f;
//      }
//
//      if (cas_if(v)) {
//        update_region
//          using Cell(s, x);
//        {
//          b := CAS(x, v, v - 2);
//        }
//      } else {
//        b := false;
//      }
//    } while (!b);
//  }
//}

//
// From Caper/BoundedReadWriteLock
//

region RWLock(id r, id s, memcell x)
  guards {
    duplicable WLOCK;
    unique WUNLOCK;
    unique RLOCK1;
    unique RUNLOCK1;
    unique RLOCK2;
    unique RUNLOCK2;
  }
  interpretation {
    Cell(s, x, ?v) && G@s &&
    (v ==  0 ? RUNLOCK1@r && RUNLOCK2@r && WUNLOCK@r :
     v ==  1 ? WUNLOCK@r && RUNLOCK2@r :
     v ==  2 ? WUNLOCK@r && RUNLOCK1@r :
     v ==  3 ? WUNLOCK@r :
     v == -1 ? RUNLOCK1@r && RUNLOCK2@r :
     false)
  }
  state { v }
  actions {
    RLOCK1   :  0 ~> Set(0, 1);
    RUNLOCK1 :  1 ~> Set(1, 0);
    RLOCK2   :  0 ~> Set(0, 2);
    RUNLOCK2 :  2 ~> Set(2, 0);
    RLOCK1   :  2 ~> Set(2, 3);
    RUNLOCK1 :  3 ~> Set(3, 2);
    RLOCK2   :  1 ~> Set(1, 3);
    RUNLOCK2 :  3 ~> Set(3, 1);
    WLOCK    :  0 ~> Set(0, -1);
    WUNLOCK  : -1 ~> Set(-1, 0);
  }

//
// From Caper/CAPLock
//

predicate Inv() /* Invariant of CAP lock (left abstract) */

region CAPLock(id r, id s, memcell x)
  guards {
    duplicable Z;
    unique K;
  }
  interpretation {
       Cell(s, x, ?v) && G@s
    && (v == 0 ==> K@r && Inv())
    && (v == 1 ==> true)
  }
  state { v }
  actions {
    Z: 0 ~> Set(0, 1);
    K: 1 ~> Set(1, 0);
  }




struct memcell {
  int f;
}

primitive_atomic bool CAS(memcell x, int now, int thn)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;
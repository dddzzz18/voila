
struct memcell {
  int f;
}

region Counter(id r, int lvl, memcell x)
  guards { duplicable INCREMENT; }
  interpretation { x.f |-> ?v }
  state { v }
  actions {
    ?n, ?m | n < m | INCREMENT: n ~> m;
  }

procedure makeCounter(int lvl) returns (memcell ret, id r)
  requires lvl >= 0;
  ensures Counter(r, lvl, ret) && INCREMENT@r;
{
  ret := new memcell(0);
  r := new Counter(lvl, ret) with INCREMENT;
}

make_atomic procedure incr(id c, int lvl, memcell x) returns (int ret)
  interference ?n in Int;
  requires Counter(c, lvl, x, n) && INCREMENT@c;
  ensures Counter(c, lvl, x, n + 1) && INCREMENT@c;
  ensures ret == n;
{
  int r;
  bool b;

  do
    invariant Counter(c, lvl, x);
    //:: ExpectedOutput(invariant_establishment_error)
    invariant  b ==> c |=> <D>;
    invariant !b ==> c |=> (r, r + 1);
  {
    open_region using Counter(c, lvl, x) {
      r := x.f;
    }
    update_region using Counter(c, lvl, x) {
      b := CAS(x, r, r + 1);
    }
  } while (!b);

  ret := r;
}

abstract_atomic procedure read(id c, int lvl, memcell x) returns (int ret)
  interference ?n in Int;
  requires Counter(c, lvl, x, n) && INCREMENT@c;
  ensures Counter(c, lvl, x, n) && INCREMENT@c;
  ensures ret == n;
{
  open_region using Counter(c, lvl, x) {
    ret := x.f;
  }
}

make_atomic procedure wkincr(id c, int lvl, memcell x) returns (int ret)
  interference ?n in Set<int>(n);
  requires Counter(c, lvl, x, n) && INCREMENT@c;
  ensures Counter(c, lvl, x, n + 1) && INCREMENT@c;
  ensures ret == n;
{
  int r;

  open_region using Counter(c, lvl, x) {
    r := x.f;
  }

  update_region using Counter(c, lvl, x) {
    x.f := r + 1;
  }

  ret := r;
}

primitive_atomic procedure CAS(memcell x, int now, int thn) returns (bool ret)
  requires x.f |-> ?v;
  ensures  v == now
              ? ret && x.f |-> thn
              : !ret && x.f |-> v;

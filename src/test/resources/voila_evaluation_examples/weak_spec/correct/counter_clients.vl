
region CClient(id a, int alvl, id c, int lvl, cell x)
  guards {
    duplicable INC(int k, frac p);
    duplicable TOTAL(int n);
  }
  interpretation {
    Counter(c, lvl, x, ?n) && lvl < alvl && G@c && TOTAL(n)@a
  }
  state { n }
  actions {
    ?n, ?m, ?k, ?p | 0f < p && n < m | INC(k, p): n ~> m;
  }

/* Model complex guard algebra via lemma procedures *

/* lemma */ procedure INC_split(id a, int k1, int k2, frac p1, frac p2)
  requires INC(k1 + k2, p1 + p2)@a;
  requires 0f < p1 && 0f < p2;
  ensures  INC(k1, p1)@a && INC(k2, p2)@a;

/* lemma */ procedure INC_join(id a, int k1, int k2, frac p1, frac p2)
  requires INC(k1, p1)@a && INC(k2, p2)@a;
  requires 0f < p1 && 0f < p2;
  ensures  INC(k1 + k2, p1 + p2)@a;

/* lemma */ procedure TOTAL_INC_equality(id a, int n, int k)
  requires TOTAL(n)@a && INC(k, 1f)@a;
//  requires TODO: ... and the composition must be defined
  ensures  TOTAL(n)@a && INC(k, 1f)@a;
  ensures  n == k;

/* lemma */ procedure TOTAL_INC_update(id a, int n, int k0, int k1, frac p)
  requires TOTAL(n + k0)@a && INC(k0, p)@a;
  requires 0f < p;
  ensures  TOTAL(n + k1)@a && INC(k1, p)@a;

/* Specialised version of (i.e. derived from) TOTAL_INC_update */
/* lemma */ procedure TOTAL_INC_inc(id a, int n, int k, frac p)
  requires TOTAL(n)@a && INC(k, p)@a && 0 <= n - k;
  requires 0f < p;
  ensures  TOTAL(n + 1)@a && INC(k + 1, p)@a;
{
  int m;
  assume n == m + k;
  use TOTAL_INC_update(a, m, k, k + 1, p);
}

/* Macro single_client's contract for easy reuse when encoding fork/join via ex-/inhales */

macro single_client_Pre(a, alvl, c, lvl, x, p)
  CClient(a, alvl, c, lvl, x, ?v0) && INC( 0, p)@a && 0f < p && 0 <= v0;

macro single_client_Post(a, alvl, c, lvl, x, p, n)
  CClient(a, alvl, c, lvl, x,  _) && INC(n, p)@a && 0 <= n;


procedure single_client(id a, int alvl, id c, int lvl, cell x, frac p) returns (int n)
  requires single_client_Pre(a, alvl, c, lvl, x, p);
  ensures single_client_Post(a, alvl, c, lvl, x, p, n);
{
  int i;

  // n := random();
  havoc n;
  assume 0 <= n;

  i := 0;

  while (i < n)
    invariant 0 <= i && i <= n;
    invariant CClient(a, alvl, c, lvl, x, ?vi) && i <= vi;
    invariant INC(i, p)@a;
  {
    use_atomic
      using CClient(a, alvl, c, lvl, x) with INC(i, p)@a;
    {
      assert Counter(c, lvl, x, ?v);
      incr(c, lvl, x);
      assert Counter(c, lvl, x, v + 1); 
      assert TOTAL(v)@a && INC(i, p)@a;
      use TOTAL_INC_inc(a, v, i, p);
    }

    i := i + 1;
  }
}



procedure run_clients_in_parallel() {
  id a, c;
  int alvl, lvl;
  cell x;
  int k1;
  int k2;

  assume alvl > lvl;

  // Create new Counter region
  // x := makeCounter();
  inhale Counter(c, lvl, x, 0) && G@c;


  // Create a new CClient region
  inhale TOTAL(0)@a && INC(0, 1f)@a;
  fold CClient(a, alvl, c, lvl, x, 0);


  // Duplicate region assertion (get a second instance) ...
  assert CClient(a, alvl, c, lvl, x);
  inhale CClient(a, alvl, c, lvl, x);

  // ... and split INC guard into two
  use INC_split(a, 0, 0, 1/2, 1/2);


  // Fork two instances of single_client
  exhale single_client_Pre(a, alvl, c, lvl, x, 1/2);
  exhale single_client_Pre(a, alvl, c, lvl, x, 1/2);


  skip; // Account for possible interference between forking and joining


  // Join the two forked instances of single_client
  havoc k1;
  inhale single_client_Post(a, alvl, c, lvl, x, 1/2, k1);
  havoc k2;
  inhale single_client_Post(a, alvl, c, lvl, x, 1/2, k2);


  // Join the two INC guards
  use INC_join(a, k1, k2, 1/2, 1/2);


  // Transform CClient assertion according to guard algebra
  unfold CClient(a, alvl, c, lvl, x, _);
  assert Counter(c, lvl, x, ?n);
  use TOTAL_INC_equality(a, n, k1 + k2);
  fold CClient(a, alvl, c, lvl, x, k1 + k2);


  // Dispose CClient region
  unfold CClient(a, alvl, c, lvl, x, k1 + k2);

  // Postcondition
  exhale Counter(c, lvl, x, k1 + k2);
}

/** Counter */

struct cell {
  int f;
}

region Counter(id c, int lvl, cell x)
  guards { unique G; }
  interpretation { x.f |-> ?n }
  state { n }
  actions { G: ?n ~> ?m; }

abstract_atomic procedure read(id c, int lvl, cell x) returns (int ret)
  interference ?n in Int on c;
  requires Counter(c, lvl, x, n) && G@c;
  ensures Counter(c, lvl, x, n) && G@c;
  ensures ret == n;

abstract_atomic procedure incr(id c, int lvl, cell x)
  interference ?n in Int on c;
  requires Counter(c, lvl, x, n) && G@c;
  ensures Counter(c, lvl, x, n + 1) && G@c;

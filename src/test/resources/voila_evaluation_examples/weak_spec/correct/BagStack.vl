// This example is motivated by:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/BagStack.t
//

struct entry {
  link next;
}

struct link {
  int val;
  link next;
}

macro nextGhost(r, b1, b2, b3) (
  r._nextId |-> b1 && r._nextLvl |-> b2 && r._nextState |-> b3
);

macro let(b1, v1) {
  havoc b1;
  assume b1 == v1;
}


region Bag(id r, int lvl, entry z)
  // We use ghost fields to model existentials in the region interpretation.
  // The value of the field represents the witness of the existential.
  ghost_fields { id _nextId; int _nextLvl; seq<int> _nextState; }
  guards { duplicable Z; }
  interpretation {
       z.next |-> ?y && nextGhost(r, ?c, ?l, ?vs)
    && BagList(c, l, y, vs) && G@c && l < lvl
  }
  state { vs }
  actions { Z: ?p ~> ?q; }

region BagList(id r, int lvl, link x)
  ghost_fields { id _nextId; int _nextLvl; seq<int> _nextState; }
  guards { unique G; }
  interpretation {
       x.val |-> ?v && x.next |-> ?y && nextGhost(r, ?c, ?l, ?vs)
    && (x != null ==> BagList(c, l, y, vs) && G@c && l < lvl)
  }
  state { x == null ? Seq<int>() : Seq<int>(v) concat vs }
  actions { G: ?p ~> ?q; }


procedure push(id r, int lvl, entry z, int n)
  requires Bag(r, lvl, z) && Z@r;
  ensures  Bag(r, lvl, z) && Z@r;
{
  link x;
  link y;
  bool b;
  id c;
  int l;

    
  x := new link(n, null);
  
  do
    invariant Bag(r, lvl, z) && Z@r;
    invariant !b ==> x.val |-> n && x.next |-> _;
  {
    open_region using Bag(r, lvl, z) {
      y := z.next;
    }
      
    x.next := y;

    use_atomic using Bag(r, lvl, z) with Z@r {

      assert z.next |-> ?u && nextGhost(r, ?ur, ?ul, ?u_state);

      b := CAS_entry(z, y, x);

      if (b) {
        // create BagList(c, l, x)
        // This constraint requires a dense level order, which by the authors of TaDA is fine.
        // That means that region levels can be represented as rationals.
        // However, Voila uses integers to stay close to the original design of TaDA.
        assume ul < l && l < lvl;
        
        c := new BagList(l, x) with G {
          c._nextId := ur;
          c._nextLvl := ul;
          c._nextState := u_state;
          assert BagList(ur, ul, u, u_state);
        }

        // update ghost state of r
        assert BagList(c, l, x, ?c_state);
        r._nextId := c;
        r._nextLvl := l;
        r._nextState := c_state;
      }
    }
  } while (!b);
}

// For the following code we use two assumptions:
// A: If the head is removed, then no one has access to it anymore
// B: The next node cannot be changed before the current node
// Both properties could be expressed through a more complicated region specification.
// In particular, such a specification requires guards that require a manual encoding in Gobra.

procedure pop(id r, int lvl, entry z) returns (int v)
  requires Bag(r, lvl, z) && Z@r;
  ensures  Bag(r, lvl, z) && Z@r;
{
  link t;
  link tn;
  bool b;
  int vi;

  b := false;

  do
    invariant Bag(r, lvl, z) && Z@r;
    invariant  b ==> t.val |-> vi;
  {
    open_region using Bag(r, lvl, z) {
      t := z.next;

      // duplicate BagList(jr, jl, t)
      assert nextGhost(r, ?jr, ?jl, _);
      duplicate BagList(jr, jl, t);
    }

    if (t != null) {

      open_region using BagList(jr, jl, t) {
        tn := t.next;
      }

      exhale BagList(jr, jl, t);

      use_atomic using Bag(r, lvl, z) with Z@r {

        assert z.next |-> ?u && nextGhost(r, ?ur, ?ul, ?u_state);

        b := CAS_entry(z, t, tn);

        if (b) {
          // destroy BagList(ur, ul, t)
          // Assumption A
          unfold BagList(ur, ul, t);
          exhale G@ur;

          assert t.next |-> ?n && nextGhost(ur, ?nr, ?nl, ?n_state);

          // Assumption B
          assume n == tn;

          r._nextId := nr;
          r._nextLvl := nl;
          r._nextState := n_state;

          assert t.val |-> ?e;
          let(vi, e);
        }
      }
    }
  } while (!b);

  v := t.val;
}



primitive_atomic procedure CAS_entry(entry x, link now, link thn) returns (bool ret)
  requires x.next |-> ?v;
  ensures  v == now
              ? ret && x.next |-> thn
              : !ret && x.next |-> v;


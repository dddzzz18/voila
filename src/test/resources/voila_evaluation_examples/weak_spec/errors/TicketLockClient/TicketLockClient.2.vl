// This example is motivated by:
//   https://github.com/caper-tool/caper/blob/master/examples/iterative/TicketLockClient.t
//

struct dualcell {
  int left;
  int right;
}

region Client(id c, int l, dualcell z, id r, int lvl, memcell x)
  // We use ghost fields to model existentials in the region interpretation.
  // The value of the field represents the witness of the existential.
  ghost_fields { int _state; bool _owned; }
  guards { duplicable Z; }
  interpretation { 
       c._state |-> ?a && c._owned |-> ?s
    && TLock(r, lvl, x, _, ?n) && lvl < l
    && (s ? TICKET(n)@r : z.left |-> a && z.right |-> a)
  }
  state { a }
  actions { Z: ?n ~> ?m; }


procedure foo(id c, int l, dualcell z, id r, int lvl, memcell x, int w)
  requires Client(c, l, z, r, lvl, x) && Z@c;
  // Incorrect postcondition.
  //:: ExpectedOutput(postcondition_error:region_state_error)
  ensures  Client(c, l, z, r, lvl, x, w) && Z@c;
{

  open_region using Client(c, l, z, r, lvl, x) {
    assert TLock(r, lvl, x, _, ?ni);

    acquire(r, lvl, x);

    // Note that others cannot have held TICKET(ni) because it is unique
    // manually asserts uniqueness of TICKET
    use_guard_uniqueness TICKET(ni)@r;

    c._owned := true;
  }

  z.left  := w;
  z.right := w;

  use_atomic using Client(c, l, z, r, lvl, x) with Z@c {
    // update witnesses
    c._state := w;
    c._owned := false;

    release(r, lvl, x);
  }
}


/** Ticket Lock */


struct memcell {
  int next;
  int owner;
}

region TLock(id r, int lvl, memcell x; int m)
  guards { unique TICKET(int n); }
  interpretation {
  	   x.owner |-> ?n && x.next |-> ?m 
    && TICKET|Set( ?k | k >= m )|@r && m >= n
  }
  state { n }
  actions {
  	?n, ?m | n < m | TICKET|Set( ?k | n <= k && k < m )|: n ~> m;
  }


abstract_atomic procedure acquire(id r, int lvl, memcell x)
  interference ?n in Set<int>(?u | true);
  requires TLock(r, lvl, x, _, n);
  ensures  TLock(r, lvl, x, _, n) && TICKET(n)@r;


abstract_atomic procedure release(id r, int lvl, memcell x)
  interference ?n in Set<int>(?u | true);
  requires TLock(r, lvl, x, _, n) && TICKET(n)@r;
  ensures  TLock(r, lvl, x, _, n+1);